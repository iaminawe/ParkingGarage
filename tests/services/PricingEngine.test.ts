/**
 * PricingEngine Tests
 * 
 * Tests for dynamic pricing, surge pricing, discount codes,
 * membership tiers, and demand-based pricing calculations
 */

import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { PricingEngine } from '../../src/services/PricingEngine';
import type { PricingContext, MembershipTier } from '../../src/services/PricingEngine';
import { prisma } from '../../src/config/database';

// Mock Prisma
jest.mock('../../src/config/database', () => ({
  prisma: {
    parkingSpot: {
      count: jest.fn()
    },
    user: {
      findUnique: jest.fn()
    }
  }
}));

// Mock BillingService
jest.mock('../../src/services/billingService', () => ({
  BillingService: jest.fn().mockImplementation(() => ({
    getSpotTypeRate: jest.fn().mockReturnValue(5.0)
  }))
}));

describe('PricingEngine', () => {
  let pricingEngine: PricingEngine;
  
  beforeEach(() => {
    pricingEngine = new PricingEngine();
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('calculatePricing', () => {
    const basePricingContext: PricingContext = {
      spotType: 'standard',
      spotFeatures: [],
      rateType: 'hourly',
      checkInTime: new Date('2024-01-15T14:00:00Z'), // Monday 2 PM
      expectedDuration: 120, // 2 hours
      userId: 'user_123'
    };

    it('should calculate base pricing correctly', async () => {
      // Mock normal occupancy (no surge)
      (prisma.parkingSpot.count as jest.Mock)
        .mockResolvedValueOnce(100) // total spots
        .mockResolvedValueOnce(30);  // occupied spots (30% occupancy)

      const result = await pricingEngine.calculatePricing(basePricingContext);

      expect(result.baseRate).toBe(5.0);
      expect(result.surgeMultiplier).toBe(1.0); // No surge at 30% occupancy
      expect(result.surgeRate).toBe(5.0);
      expect(result.membershipDiscount).toBe(0); // No membership tier provided
      expect(result.discountCodeDiscount).toBe(0); // No discount code
      expect(result.finalRate).toBe(5.0);
      expect(result.totalEstimate).toBe(10.0); // 2 hours * $5/hour
      expect(result.validUntil).toBeInstanceOf(Date);
    });

    it('should apply peak hours surge pricing', async () => {
      const peakContext = {\n        ...basePricingContext,\n        checkInTime: new Date('2024-01-15T08:00:00Z') // Monday 8 AM (peak hour)\n      };\n\n      // Mock normal occupancy\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(30);\n\n      const result = await pricingEngine.calculatePricing(peakContext);\n\n      expect(result.surgeMultiplier).toBeGreaterThan(1.0);\n      expect(result.surgeRate).toBeGreaterThan(5.0);\n      expect(result.finalRate).toBeGreaterThan(5.0);\n    });\n\n    it('should apply high occupancy surge pricing', async () => {\n      // Mock high occupancy (85%)\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100) // total spots\n        .mockResolvedValueOnce(85);  // occupied spots\n\n      const result = await pricingEngine.calculatePricing(basePricingContext);\n\n      expect(result.surgeMultiplier).toBeGreaterThan(1.5);\n      expect(result.surgeRate).toBeGreaterThan(7.5);\n      expect(result.finalRate).toBeGreaterThan(7.5);\n    });\n\n    it('should apply weekend surge pricing', async () => {\n      const weekendContext = {\n        ...basePricingContext,\n        checkInTime: new Date('2024-01-13T15:00:00Z') // Saturday 3 PM\n      };\n\n      // Mock normal occupancy\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(30);\n\n      const result = await pricingEngine.calculatePricing(weekendContext);\n\n      expect(result.surgeMultiplier).toBeGreaterThanOrEqual(1.2);\n      expect(result.surgeRate).toBeGreaterThanOrEqual(6.0);\n    });\n\n    it('should apply EV charging premium', async () => {\n      const evContext = {\n        ...basePricingContext,\n        spotFeatures: ['ev_charging'] as const\n      };\n\n      // Mock normal occupancy\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(30);\n\n      const result = await pricingEngine.calculatePricing(evContext);\n\n      expect(result.surgeMultiplier).toBeGreaterThanOrEqual(1.2); // EV charging premium\n    });\n\n    it('should apply membership discounts correctly', async () => {\n      const memberContext = {\n        ...basePricingContext,\n        membershipTier: 'PREMIUM' as MembershipTier\n      };\n\n      // Mock normal occupancy\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(30);\n\n      const result = await pricingEngine.calculatePricing(memberContext);\n\n      expect(result.membershipDiscount).toBeGreaterThan(0);\n      expect(result.finalRate).toBeLessThan(result.surgeRate);\n      expect(result.breakdown.membershipDiscountPercent).toBe(10); // PREMIUM tier gets 10%\n    });\n\n    it('should apply VIP membership discounts', async () => {\n      const vipContext = {\n        ...basePricingContext,\n        membershipTier: 'VIP' as MembershipTier\n      };\n\n      // Mock normal occupancy\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(30);\n\n      const result = await pricingEngine.calculatePricing(vipContext);\n\n      expect(result.membershipDiscount).toBeGreaterThan(0);\n      expect(result.breakdown.membershipDiscountPercent).toBe(20); // VIP tier gets 20%\n      expect(result.finalRate).toBeLessThan(result.surgeRate);\n    });\n\n    it('should apply discount codes correctly', async () => {\n      const discountContext = {\n        ...basePricingContext,\n        discountCode: 'WELCOME10'\n      };\n\n      // Mock normal occupancy\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(30);\n\n      const result = await pricingEngine.calculatePricing(discountContext);\n\n      expect(result.discountCodeDiscount).toBeGreaterThan(0);\n      expect(result.finalRate).toBeLessThan(result.surgeRate);\n      expect(result.breakdown.discountCodePercent).toBe(10); // WELCOME10 is 10% off\n    });\n\n    it('should combine membership and discount code benefits', async () => {\n      const combinedContext = {\n        ...basePricingContext,\n        membershipTier: 'PREMIUM' as MembershipTier,\n        discountCode: 'WELCOME10'\n      };\n\n      // Mock normal occupancy\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(30);\n\n      const result = await pricingEngine.calculatePricing(combinedContext);\n\n      expect(result.membershipDiscount).toBeGreaterThan(0);\n      expect(result.discountCodeDiscount).toBeGreaterThan(0);\n      expect(result.finalRate).toBeLessThan(result.surgeRate);\n      \n      const totalDiscount = result.membershipDiscount + result.discountCodeDiscount;\n      expect(result.finalRate).toBe(result.surgeRate - totalDiscount);\n    });\n\n    it('should cap surge multiplier at maximum', async () => {\n      const extremeContext = {\n        ...basePricingContext,\n        checkInTime: new Date('2024-01-12T18:30:00Z'), // Friday evening\n        spotFeatures: ['ev_charging'] as const\n      };\n\n      // Mock very high occupancy (95%)\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(95);\n\n      const result = await pricingEngine.calculatePricing(extremeContext);\n\n      expect(result.surgeMultiplier).toBeLessThanOrEqual(3.0); // Max surge cap\n    });\n\n    it('should never result in negative final rate', async () => {\n      const heavyDiscountContext = {\n        ...basePricingContext,\n        membershipTier: 'CORPORATE' as MembershipTier, // 25% discount\n        discountCode: 'SAVE20' // 20% discount\n      };\n\n      // Mock low base rate scenario\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(10);\n\n      const result = await pricingEngine.calculatePricing(heavyDiscountContext);\n\n      expect(result.finalRate).toBeGreaterThanOrEqual(0);\n      expect(result.totalEstimate).toBeGreaterThanOrEqual(0);\n    });\n  });\n\n  describe('getPricingOptions', () => {\n    const baseContext: PricingContext = {\n      spotType: 'standard',\n      spotFeatures: [],\n      rateType: 'hourly',\n      checkInTime: new Date('2024-01-15T14:00:00Z')\n    };\n\n    it('should return pricing for multiple durations', async () => {\n      // Mock normal occupancy\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValue(100)\n        .mockResolvedValue(30);\n\n      const options = await pricingEngine.getPricingOptions(baseContext);\n\n      expect(options).toHaveLength(5); // 1h, 2h, 4h, 8h, 24h\n      expect(options[0].duration).toBe(60);\n      expect(options[1].duration).toBe(120);\n      expect(options[2].duration).toBe(240);\n      expect(options[3].duration).toBe(480);\n      expect(options[4].duration).toBe(1440);\n\n      // Longer durations should cost more\n      expect(options[4].pricing.totalEstimate).toBeGreaterThan(options[0].pricing.totalEstimate);\n    });\n  });\n\n  describe('validateDiscountCode', () => {\n    it('should validate existing discount codes', async () => {\n      const result = await pricingEngine.validateDiscountCode('WELCOME10');\n\n      expect(result.valid).toBe(true);\n      expect(result.discount).toBeDefined();\n      expect(result.discount!.code).toBe('WELCOME10');\n      expect(result.discount!.type).toBe('PERCENTAGE');\n      expect(result.discount!.value).toBe(10);\n    });\n\n    it('should reject invalid discount codes', async () => {\n      const result = await pricingEngine.validateDiscountCode('INVALID_CODE');\n\n      expect(result.valid).toBe(false);\n      expect(result.reason).toBe('Discount code not found');\n      expect(result.discount).toBeUndefined();\n    });\n\n    it('should reject expired discount codes', async () => {\n      // Test with a code that would be expired\n      const result = await pricingEngine.validateDiscountCode('EXPIRED_CODE');\n\n      expect(result.valid).toBe(false);\n      expect(result.reason).toContain('not found'); // Since mock doesn't have expired codes\n    });\n  });\n\n  describe('getMembershipBenefits', () => {\n    it('should return correct benefits for each tier', () => {\n      const basicBenefits = pricingEngine.getMembershipBenefits('BASIC');\n      expect(basicBenefits!.discountPercent).toBe(0);\n      expect(basicBenefits!.priorityBooking).toBe(false);\n      expect(basicBenefits!.freeHours).toBe(0);\n\n      const premiumBenefits = pricingEngine.getMembershipBenefits('PREMIUM');\n      expect(premiumBenefits!.discountPercent).toBe(10);\n      expect(premiumBenefits!.priorityBooking).toBe(true);\n      expect(premiumBenefits!.freeHours).toBe(2);\n\n      const vipBenefits = pricingEngine.getMembershipBenefits('VIP');\n      expect(vipBenefits!.discountPercent).toBe(20);\n      expect(vipBenefits!.priorityBooking).toBe(true);\n      expect(vipBenefits!.freeHours).toBe(5);\n\n      const corporateBenefits = pricingEngine.getMembershipBenefits('CORPORATE');\n      expect(corporateBenefits!.discountPercent).toBe(25);\n      expect(corporateBenefits!.priorityBooking).toBe(true);\n      expect(corporateBenefits!.freeHours).toBe(10);\n    });\n\n    it('should return null for invalid tier', () => {\n      const benefits = pricingEngine.getMembershipBenefits('INVALID' as MembershipTier);\n      expect(benefits).toBeNull();\n    });\n  });\n\n  describe('getCurrentSurgeInfo', () => {\n    it('should return surge information for all active zones', async () => {\n      // Mock occupancy for different scenarios\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100) // total spots\n        .mockResolvedValueOnce(75)  // occupied spots (75% occupancy)\n        .mockResolvedValueOnce(100) // total spots for second zone\n        .mockResolvedValueOnce(30); // occupied spots (30% occupancy)\n\n      const surgeInfo = await pricingEngine.getCurrentSurgeInfo();\n\n      expect(surgeInfo).toBeInstanceOf(Array);\n      expect(surgeInfo.length).toBeGreaterThan(0);\n      \n      surgeInfo.forEach(info => {\n        expect(info).toHaveProperty('zone');\n        expect(info).toHaveProperty('multiplier');\n        expect(info).toHaveProperty('reason');\n        expect(info.multiplier).toBeGreaterThanOrEqual(1.0);\n      });\n    });\n  });\n\n  describe('edge cases and error handling', () => {\n    it('should handle database connection errors gracefully', async () => {\n      (prisma.parkingSpot.count as jest.Mock).mockRejectedValue(new Error('Database error'));\n\n      await expect(pricingEngine.calculatePricing(basePricingContext))\n        .rejects\n        .toThrow('Failed to calculate pricing');\n    });\n\n    it('should handle zero total spots scenario', async () => {\n      // Mock no spots available\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(0) // total spots\n        .mockResolvedValueOnce(0); // occupied spots\n\n      const result = await pricingEngine.calculatePricing(basePricingContext);\n\n      expect(result.surgeMultiplier).toBe(1.0); // No surge when no spots to occupy\n      expect(result.baseRate).toBe(5.0); // Base rate still applies\n    });\n\n    it('should handle invalid spot types gracefully', async () => {\n      const invalidContext = {\n        ...basePricingContext,\n        spotType: 'invalid_type' as any\n      };\n\n      // Mock normal occupancy\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(30);\n\n      const result = await pricingEngine.calculatePricing(invalidContext);\n\n      expect(result).toBeDefined();\n      expect(result.baseRate).toBeGreaterThan(0); // Should fall back to default rate\n    });\n\n    it('should handle very short durations', async () => {\n      const shortDurationContext = {\n        ...basePricingContext,\n        expectedDuration: 1 // 1 minute\n      };\n\n      // Mock normal occupancy\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(30);\n\n      const result = await pricingEngine.calculatePricing(shortDurationContext);\n\n      expect(result.totalEstimate).toBeGreaterThan(0);\n      expect(result.breakdown.estimatedDuration).toBe(1);\n    });\n\n    it('should handle very long durations', async () => {\n      const longDurationContext = {\n        ...basePricingContext,\n        expectedDuration: 2880 // 48 hours\n      };\n\n      // Mock normal occupancy\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(30);\n\n      const result = await pricingEngine.calculatePricing(longDurationContext);\n\n      expect(result.totalEstimate).toBeGreaterThan(result.baseRate * 24); // Should cost more than 24 hours of base rate\n      expect(result.breakdown.estimatedDuration).toBe(2880);\n    });\n  });\n\n  describe('discount code restrictions', () => {\n    it('should respect spot type restrictions', async () => {\n      const restrictedContext = {\n        ...basePricingContext,\n        spotType: 'compact' as const,\n        discountCode: 'SAVE20' // Only valid for standard/oversized\n      };\n\n      // Mock normal occupancy\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(30);\n\n      const result = await pricingEngine.calculatePricing(restrictedContext);\n\n      expect(result.discountCodeDiscount).toBe(0); // Should not apply discount\n      expect(result.breakdown.discountCodePercent).toBe(0);\n    });\n\n    it('should respect membership tier restrictions', async () => {\n      const restrictedContext = {\n        ...basePricingContext,\n        membershipTier: 'BASIC' as MembershipTier,\n        discountCode: 'PREMIUM5' // Only for PREMIUM/VIP members\n      };\n\n      // Mock normal occupancy\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(30);\n\n      const result = await pricingEngine.calculatePricing(restrictedContext);\n\n      expect(result.discountCodeDiscount).toBe(0); // Should not apply discount\n    });\n\n    it('should apply fixed amount discounts correctly', async () => {\n      const fixedDiscountContext = {\n        ...basePricingContext,\n        membershipTier: 'PREMIUM' as MembershipTier, // Required for PREMIUM5 code\n        discountCode: 'PREMIUM5' // $5 fixed discount\n      };\n\n      // Mock normal occupancy\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(30);\n\n      const result = await pricingEngine.calculatePricing(fixedDiscountContext);\n\n      expect(result.discountCodeDiscount).toBe(5); // Fixed $5 discount\n    });\n  });\n});