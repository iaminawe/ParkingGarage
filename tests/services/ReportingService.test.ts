/**
 * ReportingService Tests
 * 
 * Tests for occupancy reports, revenue reports, user activity reports,
 * admin dashboard data, and audit logging functionality
 */

import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { ReportingService } from '../../src/services/ReportingService';
import type { ReportOptions } from '../../src/services/ReportingService';
import { prisma } from '../../src/config/database';

// Mock Prisma
jest.mock('../../src/config/database', () => ({
  prisma: {
    parkingSpot: {
      count: jest.fn(),
      groupBy: jest.fn()
    },
    parkingSession: {
      findMany: jest.fn(),
      count: jest.fn(),
      aggregate: jest.fn()
    },
    payment: {
      findMany: jest.fn(),
      count: jest.fn(),
      aggregate: jest.fn()
    },
    user: {
      count: jest.fn()
    },
    securityAuditLog: {
      findMany: jest.fn(),
      count: jest.fn()
    }
  }
}));

// Mock SecurityAuditService
jest.mock('../../src/services/SecurityAuditService', () => ({
  SecurityAuditService: jest.fn().mockImplementation(() => ({
    logSecurityEvent: jest.fn().mockResolvedValue(true)
  }))
}));

describe('ReportingService', () => {
  let reportingService: ReportingService;
  
  const baseReportOptions: ReportOptions = {
    startDate: new Date('2024-01-01T00:00:00Z'),
    endDate: new Date('2024-01-31T23:59:59Z'),
    groupBy: 'day'
  };

  beforeEach(() => {
    reportingService = new ReportingService();
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('generateOccupancyReport', () => {
    it('should generate comprehensive occupancy report', async () => {
      // Mock spot counts\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(200) // total spots\n        .mockResolvedValueOnce(150) // currently occupied\n        .mockResolvedValueOnce(50)  // compact total\n        .mockResolvedValueOnce(30)  // compact occupied\n        .mockResolvedValueOnce(100) // standard total\n        .mockResolvedValueOnce(80)  // standard occupied\n        .mockResolvedValueOnce(50)  // oversized total\n        .mockResolvedValueOnce(40); // oversized occupied\n\n      // Mock floor grouping\n      (prisma.parkingSpot.groupBy as jest.Mock).mockResolvedValue([\n        { level: 1, _count: { _all: 80 } },\n        { level: 2, _count: { _all: 70 } },\n        { level: 3, _count: { _all: 50 } }\n      ]);\n\n      // Mock occupied counts by floor\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(60) // floor 1 occupied\n        .mockResolvedValueOnce(50) // floor 2 occupied\n        .mockResolvedValueOnce(40); // floor 3 occupied\n\n      // Mock historical sessions\n      (prisma.parkingSession.findMany as jest.Mock).mockResolvedValue([\n        {\n          id: 'session_1',\n          startTime: new Date('2024-01-15T10:00:00Z'),\n          endTime: new Date('2024-01-15T12:00:00Z'),\n          spot: { spotType: 'STANDARD' }\n        },\n        {\n          id: 'session_2',\n          startTime: new Date('2024-01-15T14:00:00Z'),\n          endTime: new Date('2024-01-15T16:00:00Z'),\n          spot: { spotType: 'COMPACT' }\n        }\n      ]);\n\n      const report = await reportingService.generateOccupancyReport(baseReportOptions);\n\n      expect(report.totalSpots).toBe(200);\n      expect(report.occupiedSpots).toBe(150);\n      expect(report.occupancyRate).toBe(75); // 150/200 * 100\n      expect(report.period).toContain('2024-01-01');\n      expect(report.period).toContain('2024-01-31');\n      \n      // Check spot type breakdown\n      expect(report.bySpotType).toHaveProperty('compact');\n      expect(report.bySpotType).toHaveProperty('standard');\n      expect(report.bySpotType).toHaveProperty('oversized');\n      expect(report.bySpotType.compact.total).toBe(50);\n      expect(report.bySpotType.compact.occupied).toBe(30);\n      expect(report.bySpotType.compact.rate).toBe(60);\n      \n      // Check floor breakdown\n      expect(report.byFloor).toHaveProperty('1');\n      expect(report.byFloor).toHaveProperty('2');\n      expect(report.byFloor).toHaveProperty('3');\n      expect(report.byFloor[1].total).toBe(80);\n      expect(report.byFloor[1].occupied).toBe(60);\n      expect(report.byFloor[1].rate).toBe(75);\n      \n      // Check trends\n      expect(report.trends).toBeInstanceOf(Array);\n      expect(report.averageOccupancy).toBeGreaterThan(0);\n      expect(report.peakOccupancy).toBeGreaterThanOrEqual(report.occupancyRate);\n    });\n\n    it('should handle zero spots scenario', async () => {\n      (prisma.parkingSpot.count as jest.Mock).mockResolvedValue(0);\n      (prisma.parkingSpot.groupBy as jest.Mock).mockResolvedValue([]);\n      (prisma.parkingSession.findMany as jest.Mock).mockResolvedValue([]);\n\n      const report = await reportingService.generateOccupancyReport(baseReportOptions);\n\n      expect(report.totalSpots).toBe(0);\n      expect(report.occupiedSpots).toBe(0);\n      expect(report.occupancyRate).toBe(0);\n      expect(report.averageOccupancy).toBe(0);\n    });\n\n    it('should filter by spot types when specified', async () => {\n      const filteredOptions = {\n        ...baseReportOptions,\n        spotTypes: ['standard', 'oversized'] as const\n      };\n\n      (prisma.parkingSpot.count as jest.Mock).mockResolvedValue(150);\n      (prisma.parkingSpot.groupBy as jest.Mock).mockResolvedValue([]);\n      (prisma.parkingSession.findMany as jest.Mock).mockResolvedValue([]);\n\n      await reportingService.generateOccupancyReport(filteredOptions);\n\n      expect(prisma.parkingSpot.count).toHaveBeenCalledWith(\n        expect.objectContaining({\n          where: expect.objectContaining({\n            spotType: { in: ['STANDARD', 'OVERSIZED'] }\n          })\n        })\n      );\n    });\n\n    it('should filter by floors when specified', async () => {\n      const floorFilteredOptions = {\n        ...baseReportOptions,\n        floors: [1, 2]\n      };\n\n      (prisma.parkingSpot.count as jest.Mock).mockResolvedValue(100);\n      (prisma.parkingSpot.groupBy as jest.Mock).mockResolvedValue([]);\n      (prisma.parkingSession.findMany as jest.Mock).mockResolvedValue([]);\n\n      await reportingService.generateOccupancyReport(floorFilteredOptions);\n\n      expect(prisma.parkingSpot.count).toHaveBeenCalledWith(\n        expect.objectContaining({\n          where: expect.objectContaining({\n            level: { in: [1, 2] }\n          })\n        })\n      );\n    });\n  });\n\n  describe('generateRevenueReport', () => {\n    const mockPayments = [\n      {\n        id: 'payment_1',\n        amount: 25.00,\n        currency: 'USD',\n        paymentMethod: 'CREDIT_CARD',\n        status: 'COMPLETED',\n        processedAt: new Date('2024-01-15T10:30:00Z'),\n        refundAmount: 0,\n        session: {\n          spot: { spotType: 'STANDARD' }\n        }\n      },\n      {\n        id: 'payment_2',\n        amount: 15.00,\n        currency: 'USD',\n        paymentMethod: 'MOBILE_PAY',\n        status: 'COMPLETED',\n        processedAt: new Date('2024-01-15T14:30:00Z'),\n        refundAmount: 5.00,\n        session: {\n          spot: { spotType: 'COMPACT' }\n        }\n      }\n    ];\n\n    it('should generate comprehensive revenue report', async () => {\n      (prisma.payment.findMany as jest.Mock).mockResolvedValue(mockPayments);\n\n      const report = await reportingService.generateRevenueReport(baseReportOptions);\n\n      expect(report.totalRevenue).toBe(40.00);\n      expect(report.totalTransactions).toBe(2);\n      expect(report.averageTransactionValue).toBe(20.00);\n      expect(report.period).toContain('2024-01-01');\n      \n      // Check payment method breakdown\n      expect(report.byPaymentMethod).toHaveProperty('CREDIT_CARD');\n      expect(report.byPaymentMethod).toHaveProperty('MOBILE_PAY');\n      expect(report.byPaymentMethod.CREDIT_CARD.amount).toBe(25.00);\n      expect(report.byPaymentMethod.CREDIT_CARD.transactions).toBe(1);\n      expect(report.byPaymentMethod.CREDIT_CARD.percentage).toBe(62.5);\n      \n      // Check spot type breakdown\n      expect(report.bySpotType).toHaveProperty('standard');\n      expect(report.bySpotType).toHaveProperty('compact');\n      expect(report.bySpotType.standard.revenue).toBe(25.00);\n      expect(report.bySpotType.compact.revenue).toBe(15.00);\n      \n      // Check refund information\n      expect(report.refunds.total).toBe(1);\n      expect(report.refunds.amount).toBe(5.00);\n      expect(report.refunds.refundRate).toBe(50); // 1 out of 2 payments had refunds\n      \n      // Check time of day breakdown\n      expect(report.byTimeOfDay).toHaveLength(24);\n      expect(report.byTimeOfDay[10].revenue).toBe(25.00); // 10 AM\n      expect(report.byTimeOfDay[14].revenue).toBe(15.00); // 2 PM\n    });\n\n    it('should handle zero revenue scenario', async () => {\n      (prisma.payment.findMany as jest.Mock).mockResolvedValue([]);\n\n      const report = await reportingService.generateRevenueReport(baseReportOptions);\n\n      expect(report.totalRevenue).toBe(0);\n      expect(report.totalTransactions).toBe(0);\n      expect(report.averageTransactionValue).toBe(0);\n      expect(report.refunds.refundRate).toBe(0);\n    });\n\n    it('should calculate payment method percentages correctly', async () => {\n      const equalPayments = [\n        {\n          ...mockPayments[0],\n          amount: 20.00,\n          paymentMethod: 'CREDIT_CARD'\n        },\n        {\n          ...mockPayments[1],\n          amount: 20.00,\n          paymentMethod: 'CREDIT_CARD',\n          refundAmount: 0\n        }\n      ];\n\n      (prisma.payment.findMany as jest.Mock).mockResolvedValue(equalPayments);\n\n      const report = await reportingService.generateRevenueReport(baseReportOptions);\n\n      expect(report.byPaymentMethod.CREDIT_CARD.percentage).toBe(100);\n      expect(report.totalRevenue).toBe(40.00);\n    });\n  });\n\n  describe('generateUserActivityReport', () => {\n    const mockSessions = [\n      {\n        id: 'session_1',\n        startTime: new Date('2024-01-15T10:00:00Z'),\n        duration: 120,\n        amountPaid: 25.00,\n        vehicle: {\n          ownerId: 'user_1',\n          owner: { email: 'user1@example.com' }\n        }\n      },\n      {\n        id: 'session_2',\n        startTime: new Date('2024-01-16T14:00:00Z'),\n        duration: 90,\n        amountPaid: 15.00,\n        vehicle: {\n          ownerId: 'user_1',\n          owner: { email: 'user1@example.com' }\n        }\n      },\n      {\n        id: 'session_3',\n        startTime: new Date('2024-01-17T11:00:00Z'),\n        duration: 180,\n        amountPaid: 30.00,\n        vehicle: {\n          ownerId: 'user_2',\n          owner: { email: 'user2@example.com' }\n        }\n      }\n    ];\n\n    it('should generate comprehensive user activity report', async () => {\n      // Mock user counts\n      (prisma.user.count as jest.Mock)\n        .mockResolvedValueOnce(1000) // total users\n        .mockResolvedValueOnce(250)  // active users\n        .mockResolvedValueOnce(50);  // new users\n\n      // Mock session data\n      (prisma.parkingSession.findMany as jest.Mock).mockResolvedValue(mockSessions);\n\n      const report = await reportingService.generateUserActivityReport(baseReportOptions);\n\n      expect(report.totalUsers).toBe(1000);\n      expect(report.activeUsers).toBe(250);\n      expect(report.newUsers).toBe(50);\n      expect(report.returningUsers).toBe(200); // active - new\n      expect(report.userRetentionRate).toBe(20); // returning / total * 100\n      expect(report.averageSessionDuration).toBe(130); // (120 + 90 + 180) / 3\n      \n      // Check most active users\n      expect(report.mostActiveUsers).toHaveLength(2);\n      expect(report.mostActiveUsers[0].userId).toBe('user_1');\n      expect(report.mostActiveUsers[0].sessionCount).toBe(2);\n      expect(report.mostActiveUsers[0].totalSpent).toBe(40.00);\n      expect(report.mostActiveUsers[1].userId).toBe('user_2');\n      expect(report.mostActiveUsers[1].sessionCount).toBe(1);\n      expect(report.mostActiveUsers[1].totalSpent).toBe(30.00);\n      \n      // Check user segments\n      expect(report.userSegments.byMembershipTier).toHaveProperty('BASIC');\n      expect(report.userSegments.byMembershipTier).toHaveProperty('PREMIUM');\n      expect(report.userSegments.byUsageFrequency).toHaveProperty('Daily');\n      expect(report.userSegments.byUsageFrequency).toHaveProperty('Weekly');\n    });\n\n    it('should handle zero users scenario', async () => {\n      (prisma.user.count as jest.Mock).mockResolvedValue(0);\n      (prisma.parkingSession.findMany as jest.Mock).mockResolvedValue([]);\n\n      const report = await reportingService.generateUserActivityReport(baseReportOptions);\n\n      expect(report.totalUsers).toBe(0);\n      expect(report.activeUsers).toBe(0);\n      expect(report.userRetentionRate).toBe(0);\n      expect(report.averageSessionDuration).toBe(0);\n      expect(report.mostActiveUsers).toHaveLength(0);\n    });\n\n    it('should sort most active users correctly', async () => {\n      const sessionsWithMultipleUsers = [\n        // User 3: 3 sessions\n        ...Array(3).fill(null).map((_, i) => ({\n          id: `session_user3_${i}`,\n          startTime: new Date(),\n          duration: 60,\n          amountPaid: 10.00,\n          vehicle: {\n            ownerId: 'user_3',\n            owner: { email: 'user3@example.com' }\n          }\n        })),\n        // User 4: 1 session\n        {\n          id: 'session_user4_1',\n          startTime: new Date(),\n          duration: 120,\n          amountPaid: 50.00,\n          vehicle: {\n            ownerId: 'user_4',\n            owner: { email: 'user4@example.com' }\n          }\n        }\n      ];\n\n      (prisma.user.count as jest.Mock).mockResolvedValue(100);\n      (prisma.parkingSession.findMany as jest.Mock).mockResolvedValue(sessionsWithMultipleUsers);\n\n      const report = await reportingService.generateUserActivityReport(baseReportOptions);\n\n      // User 3 should be first (more sessions)\n      expect(report.mostActiveUsers[0].userId).toBe('user_3');\n      expect(report.mostActiveUsers[0].sessionCount).toBe(3);\n      expect(report.mostActiveUsers[1].userId).toBe('user_4');\n      expect(report.mostActiveUsers[1].sessionCount).toBe(1);\n    });\n  });\n\n  describe('getAdminDashboardData', () => {\n    it('should generate comprehensive dashboard data', async () => {\n      // Mock summary data\n      jest.spyOn(reportingService as any, 'getCurrentOccupancyRate').mockResolvedValue(75.5);\n      jest.spyOn(reportingService as any, 'getTodayRevenue').mockResolvedValue(1250.00);\n      \n      (prisma.parkingSession.count as jest.Mock).mockResolvedValue(45); // active reservations\n      (prisma.securityAuditLog.count as jest.Mock).mockResolvedValue(3); // recent errors\n\n      // Mock realtime trend methods\n      jest.spyOn(reportingService as any, 'generateRealtimeOccupancyTrend')\n        .mockResolvedValue(Array(12).fill({ time: new Date(), value: 75 }));\n      jest.spyOn(reportingService as any, 'generateRealtimeRevenueTrend')\n        .mockResolvedValue(Array(12).fill({ time: new Date(), value: 100 }));\n      jest.spyOn(reportingService as any, 'generateRealtimeUserActivity')\n        .mockResolvedValue(Array(12).fill({ time: new Date(), count: 5 }));\n\n      const dashboardData = await reportingService.getAdminDashboardData();\n\n      expect(dashboardData.summary.currentOccupancy).toBe(75.5);\n      expect(dashboardData.summary.todayRevenue).toBe(1250.00);\n      expect(dashboardData.summary.activeReservations).toBe(45);\n      expect(dashboardData.summary.pendingIssues).toBe(3);\n      \n      expect(dashboardData.realtimeMetrics.occupancyTrend).toHaveLength(12);\n      expect(dashboardData.realtimeMetrics.revenueTrend).toHaveLength(12);\n      expect(dashboardData.realtimeMetrics.userActivity).toHaveLength(12);\n      \n      expect(dashboardData.alerts).toBeInstanceOf(Array);\n      expect(dashboardData.systemHealth).toHaveProperty('apiResponseTime');\n      expect(dashboardData.systemHealth).toHaveProperty('databasePerformance');\n      expect(dashboardData.systemHealth).toHaveProperty('paymentSystemStatus');\n      expect(dashboardData.systemHealth).toHaveProperty('errorRate');\n    });\n\n    it('should handle dashboard data generation errors', async () => {\n      jest.spyOn(reportingService as any, 'getCurrentOccupancyRate')\n        .mockRejectedValue(new Error('Occupancy calculation failed'));\n\n      await expect(reportingService.getAdminDashboardData())\n        .rejects.toThrow('Failed to generate admin dashboard data');\n    });\n  });\n\n  describe('getAuditLogs', () => {\n    const mockAuditLogs = [\n      {\n        id: 'log_1',\n        userId: 'user_123',\n        action: 'LOGIN_SUCCESSFUL',\n        category: 'AUTH',\n        severity: 'LOW',\n        description: 'User logged in successfully',\n        ipAddress: '192.168.1.100',\n        userAgent: 'Mozilla/5.0...',\n        metadata: JSON.stringify({ sessionId: 'session_123' }),\n        riskLevel: 'LOW',\n        createdAt: new Date('2024-01-15T10:00:00Z'),\n        user: {\n          email: 'test@example.com'\n        }\n      },\n      {\n        id: 'log_2',\n        userId: 'user_456',\n        action: 'PAYMENT_FAILED',\n        category: 'TRANSACTION',\n        severity: 'MEDIUM',\n        description: 'Payment processing failed',\n        ipAddress: '192.168.1.101',\n        userAgent: null,\n        metadata: null,\n        riskLevel: 'MEDIUM',\n        createdAt: new Date('2024-01-15T11:00:00Z'),\n        user: {\n          email: 'user2@example.com'\n        }\n      }\n    ];\n\n    it('should retrieve and format audit logs correctly', async () => {\n      (prisma.securityAuditLog.findMany as jest.Mock).mockResolvedValue(mockAuditLogs);\n      (prisma.securityAuditLog.count as jest.Mock).mockResolvedValue(2);\n\n      const result = await reportingService.getAuditLogs({\n        startDate: new Date('2024-01-15T00:00:00Z'),\n        endDate: new Date('2024-01-15T23:59:59Z'),\n        limit: 50\n      });\n\n      expect(result.logs).toHaveLength(2);\n      expect(result.total).toBe(2);\n      \n      const firstLog = result.logs[0];\n      expect(firstLog.id).toBe('log_1');\n      expect(firstLog.userId).toBe('user_123');\n      expect(firstLog.userEmail).toBe('test@example.com');\n      expect(firstLog.action).toBe('LOGIN_SUCCESSFUL');\n      expect(firstLog.severity).toBe('LOW');\n      expect(firstLog.metadata).toEqual({ sessionId: 'session_123' });\n      \n      const secondLog = result.logs[1];\n      expect(secondLog.metadata).toBeUndefined(); // null metadata should be undefined\n    });\n\n    it('should apply filters correctly', async () => {\n      (prisma.securityAuditLog.findMany as jest.Mock).mockResolvedValue([]);\n      (prisma.securityAuditLog.count as jest.Mock).mockResolvedValue(0);\n\n      await reportingService.getAuditLogs({\n        userId: 'user_123',\n        action: 'LOGIN',\n        severity: 'HIGH',\n        limit: 10,\n        offset: 20\n      });\n\n      expect(prisma.securityAuditLog.findMany).toHaveBeenCalledWith({\n        where: {\n          userId: 'user_123',\n          action: { contains: 'LOGIN' },\n          severity: 'HIGH'\n        },\n        include: {\n          user: {\n            select: { email: true }\n          }\n        },\n        orderBy: { createdAt: 'desc' },\n        take: 10,\n        skip: 20\n      });\n    });\n\n    it('should handle date range filters', async () => {\n      const startDate = new Date('2024-01-01T00:00:00Z');\n      const endDate = new Date('2024-01-31T23:59:59Z');\n\n      (prisma.securityAuditLog.findMany as jest.Mock).mockResolvedValue([]);\n      (prisma.securityAuditLog.count as jest.Mock).mockResolvedValue(0);\n\n      await reportingService.getAuditLogs({ startDate, endDate });\n\n      expect(prisma.securityAuditLog.findMany).toHaveBeenCalledWith(\n        expect.objectContaining({\n          where: {\n            createdAt: {\n              gte: startDate,\n              lte: endDate\n            }\n          }\n        })\n      );\n    });\n  });\n\n  describe('exportReport', () => {\n    it('should export occupancy report in CSV format', async () => {\n      // Mock occupancy report generation\n      jest.spyOn(reportingService, 'generateOccupancyReport').mockResolvedValue({\n        period: 'January 2024',\n        totalSpots: 200,\n        occupiedSpots: 150,\n        occupancyRate: 75,\n        peakOccupancy: 90,\n        peakOccupancyTime: new Date(),\n        averageOccupancy: 70,\n        bySpotType: {\n          compact: { total: 50, occupied: 30, rate: 60 },\n          standard: { total: 100, occupied: 80, rate: 80 },\n          oversized: { total: 50, occupied: 40, rate: 80 }\n        },\n        byFloor: {\n          1: { total: 80, occupied: 60, rate: 75 }\n        },\n        trends: []\n      });\n\n      const result = await reportingService.exportReport(\n        'occupancy',\n        baseReportOptions,\n        { format: 'CSV' }\n      );\n\n      expect(result.success).toBe(true);\n      expect(result.fileUrl).toContain('occupancy_report_');\n      expect(result.fileUrl).toContain('.csv');\n      expect(result.message).toContain('CSV');\n    });\n\n    it('should export revenue report in PDF format', async () => {\n      jest.spyOn(reportingService, 'generateRevenueReport').mockResolvedValue({\n        period: 'January 2024',\n        totalRevenue: 5000,\n        totalTransactions: 200,\n        averageTransactionValue: 25,\n        revenueGrowth: 15,\n        byPaymentMethod: {},\n        bySpotType: {\n          compact: { revenue: 1000, sessions: 50, averageValue: 20 },\n          standard: { revenue: 3000, sessions: 100, averageValue: 30 },\n          oversized: { revenue: 2000, sessions: 50, averageValue: 40 }\n        },\n        byTimeOfDay: [],\n        refunds: { total: 5, amount: 100, refundRate: 2.5 }\n      });\n\n      const result = await reportingService.exportReport(\n        'revenue',\n        baseReportOptions,\n        { format: 'PDF', includeCharts: true }\n      );\n\n      expect(result.success).toBe(true);\n      expect(result.fileUrl).toContain('revenue_report_');\n      expect(result.fileUrl).toContain('.pdf');\n    });\n\n    it('should export activity report in EXCEL format', async () => {\n      jest.spyOn(reportingService, 'generateUserActivityReport').mockResolvedValue({\n        period: 'January 2024',\n        totalUsers: 1000,\n        activeUsers: 250,\n        newUsers: 50,\n        returningUsers: 200,\n        userRetentionRate: 20,\n        averageSessionDuration: 120,\n        mostActiveUsers: [],\n        userSegments: {\n          byMembershipTier: {},\n          byUsageFrequency: {}\n        }\n      });\n\n      const result = await reportingService.exportReport(\n        'activity',\n        baseReportOptions,\n        { format: 'EXCEL' }\n      );\n\n      expect(result.success).toBe(true);\n      expect(result.fileUrl).toContain('activity_report_');\n      expect(result.fileUrl).toContain('.excel');\n    });\n\n    it('should handle invalid report type', async () => {\n      const result = await reportingService.exportReport(\n        'invalid' as any,\n        baseReportOptions,\n        { format: 'CSV' }\n      );\n\n      expect(result.success).toBe(false);\n      expect(result.message).toBe('Failed to export report');\n    });\n\n    it('should handle export generation errors', async () => {\n      jest.spyOn(reportingService, 'generateOccupancyReport')\n        .mockRejectedValue(new Error('Report generation failed'));\n\n      const result = await reportingService.exportReport(\n        'occupancy',\n        baseReportOptions,\n        { format: 'CSV' }\n      );\n\n      expect(result.success).toBe(false);\n      expect(result.message).toBe('Failed to export report');\n    });\n  });\n\n  describe('error handling', () => {\n    it('should handle database errors in occupancy report', async () => {\n      (prisma.parkingSpot.count as jest.Mock).mockRejectedValue(new Error('Database error'));\n\n      await expect(reportingService.generateOccupancyReport(baseReportOptions))\n        .rejects.toThrow('Failed to generate occupancy report');\n    });\n\n    it('should handle database errors in revenue report', async () => {\n      (prisma.payment.findMany as jest.Mock).mockRejectedValue(new Error('Database error'));\n\n      await expect(reportingService.generateRevenueReport(baseReportOptions))\n        .rejects.toThrow('Failed to generate revenue report');\n    });\n\n    it('should handle database errors in user activity report', async () => {\n      (prisma.user.count as jest.Mock).mockRejectedValue(new Error('Database error'));\n\n      await expect(reportingService.generateUserActivityReport(baseReportOptions))\n        .rejects.toThrow('Failed to generate user activity report');\n    });\n\n    it('should handle audit log retrieval errors', async () => {\n      (prisma.securityAuditLog.findMany as jest.Mock).mockRejectedValue(new Error('Database error'));\n\n      await expect(reportingService.getAuditLogs({}))\n        .rejects.toThrow('Failed to retrieve audit logs');\n    });\n  });\n\n  describe('helper methods', () => {\n    it('should calculate current occupancy rate correctly', async () => {\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(200) // total\n        .mockResolvedValueOnce(150); // occupied\n\n      const rate = await (reportingService as any).getCurrentOccupancyRate();\n\n      expect(rate).toBe(75); // 150/200 * 100\n    });\n\n    it('should handle zero spots in occupancy calculation', async () => {\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(0) // total\n        .mockResolvedValueOnce(0); // occupied\n\n      const rate = await (reportingService as any).getCurrentOccupancyRate();\n\n      expect(rate).toBe(0);\n    });\n\n    it('should calculate today revenue correctly', async () => {\n      const mockTodayStart = new Date();\n      mockTodayStart.setHours(0, 0, 0, 0);\n\n      (prisma.payment.aggregate as jest.Mock).mockResolvedValue({\n        _sum: { amount: 1250.00 }\n      });\n\n      const revenue = await (reportingService as any).getTodayRevenue(mockTodayStart);\n\n      expect(revenue).toBe(1250.00);\n      expect(prisma.payment.aggregate).toHaveBeenCalledWith({\n        where: {\n          status: 'COMPLETED',\n          processedAt: { gte: mockTodayStart }\n        },\n        _sum: { amount: true }\n      });\n    });\n\n    it('should handle null revenue aggregate', async () => {\n      (prisma.payment.aggregate as jest.Mock).mockResolvedValue({\n        _sum: { amount: null }\n      });\n\n      const revenue = await (reportingService as any).getTodayRevenue(new Date());\n\n      expect(revenue).toBe(0);\n    });\n  });\n});