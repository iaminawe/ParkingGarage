/**
 * ReservationService Tests
 * 
 * Tests for reservation creation, conflict detection, waitlist management,
 * auto-cancellation, and reservation validation
 */

import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { ReservationService } from '../../src/services/ReservationService';
import type { ReservationRequest } from '../../src/services/ReservationService';
import { prisma } from '../../src/config/database';

// Mock Prisma
jest.mock('../../src/config/database', () => ({
  prisma: {
    parkingSession: {
      create: jest.fn(),
      findUnique: jest.fn(),
      findMany: jest.fn(),
      update: jest.fn(),
      count: jest.fn(),
      aggregate: jest.fn()
    },
    parkingSpot: {
      findUnique: jest.fn(),
      findMany: jest.fn(),
      update: jest.fn(),
      count: jest.fn()
    },
    user: {
      findUnique: jest.fn()
    },
    $transaction: jest.fn()
  }
}));

// Mock SecurityAuditService
jest.mock('../../src/services/SecurityAuditService', () => ({
  SecurityAuditService: jest.fn().mockImplementation(() => ({
    logSecurityEvent: jest.fn().mockResolvedValue(true)
  }))
}));

describe('ReservationService', () => {
  let reservationService: ReservationService;
  
  beforeEach(() => {
    reservationService = new ReservationService();
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('createReservation', () => {
    const validReservationRequest: ReservationRequest = {
      userId: 'user_123',
      spotType: 'standard',
      preferredFeatures: [],
      startTime: new Date('2024-01-20T10:00:00Z'),
      endTime: new Date('2024-01-20T12:00:00Z'),
      vehicleInfo: {
        licensePlate: 'ABC123',
        make: 'Toyota',
        model: 'Camry',
        color: 'Blue'
      },
      notes: 'Business meeting parking',
      allowWaitlist: true
    };

    it('should successfully create a reservation', async () => {
      // Mock user validation\n      (prisma.user.findUnique as jest.Mock).mockResolvedValue({\n        id: 'user_123',\n        isActive: true,\n        email: 'test@example.com'\n      });\n\n      // Mock available spot\n      (prisma.parkingSpot.findMany as jest.Mock).mockResolvedValue([\n        {\n          id: 'spot_123',\n          spotNumber: 'A-101',\n          level: 1,\n          spotType: 'STANDARD',\n          status: 'AVAILABLE',\n          isActive: true,\n          sessions: [] // No conflicts\n        }\n      ]);\n\n      // Mock no conflicts\n      (prisma.parkingSession.findMany as jest.Mock).mockResolvedValue([]);\n\n      // Mock transaction\n      const mockReservation = {\n        id: 'reservation_123',\n        startTime: validReservationRequest.startTime,\n        totalAmount: 10.0,\n        status: 'ACTIVE',\n        vehicle: {\n          id: 'vehicle_123',\n          licensePlate: 'ABC123'\n        },\n        spot: {\n          id: 'spot_123',\n          spotNumber: 'A-101'\n        }\n      };\n\n      (prisma.$transaction as jest.Mock).mockImplementation(async (callback) => {\n        return await callback({\n          parkingSession: {\n            create: jest.fn().mockResolvedValue(mockReservation)\n          },\n          parkingSpot: {\n            update: jest.fn().mockResolvedValue({})\n          }\n        });\n      });\n\n      const result = await reservationService.createReservation(validReservationRequest);\n\n      expect(result.success).toBe(true);\n      expect(result.status).toBe('CONFIRMED');\n      expect(result.reservationId).toBe('reservation_123');\n      expect(result.spotId).toBe('spot_123');\n      expect(result.message).toContain('Reservation confirmed');\n    });\n\n    it('should reject reservation with invalid time range', async () => {\n      const invalidRequest = {\n        ...validReservationRequest,\n        startTime: new Date('2024-01-19T10:00:00Z'), // Past date\n        endTime: new Date('2024-01-19T12:00:00Z')\n      };\n\n      const result = await reservationService.createReservation(invalidRequest);\n\n      expect(result.success).toBe(false);\n      expect(result.status).toBe('CANCELLED');\n      expect(result.message).toContain('Start time must be in the future');\n    });\n\n    it('should reject reservation where end time is before start time', async () => {\n      const invalidRequest = {\n        ...validReservationRequest,\n        endTime: new Date('2024-01-20T08:00:00Z') // Before start time\n      };\n\n      const result = await reservationService.createReservation(invalidRequest);\n\n      expect(result.success).toBe(false);\n      expect(result.status).toBe('CANCELLED');\n      expect(result.message).toContain('End time must be after start time');\n    });\n\n    it('should reject reservation exceeding maximum duration', async () => {\n      const longDurationRequest = {\n        ...validReservationRequest,\n        endTime: new Date('2024-01-22T10:00:00Z') // 48 hours later\n      };\n\n      const result = await reservationService.createReservation(longDurationRequest);\n\n      expect(result.success).toBe(false);\n      expect(result.status).toBe('CANCELLED');\n      expect(result.message).toContain('Maximum reservation duration is 24 hours');\n    });\n\n    it('should reject reservation with too short duration', async () => {\n      const shortDurationRequest = {\n        ...validReservationRequest,\n        endTime: new Date('2024-01-20T10:15:00Z') // Only 15 minutes\n      };\n\n      const result = await reservationService.createReservation(shortDurationRequest);\n\n      expect(result.success).toBe(false);\n      expect(result.status).toBe('CANCELLED');\n      expect(result.message).toContain('Minimum reservation duration is 30 minutes');\n    });\n\n    it('should reject reservation with missing license plate', async () => {\n      const invalidRequest = {\n        ...validReservationRequest,\n        vehicleInfo: {\n          ...validReservationRequest.vehicleInfo,\n          licensePlate: ''\n        }\n      };\n\n      const result = await reservationService.createReservation(invalidRequest);\n\n      expect(result.success).toBe(false);\n      expect(result.status).toBe('CANCELLED');\n      expect(result.message).toContain('License plate is required');\n    });\n\n    it('should add to waitlist when no spots available', async () => {\n      // Mock user validation\n      (prisma.user.findUnique as jest.Mock).mockResolvedValue({\n        id: 'user_123',\n        isActive: true\n      });\n\n      // Mock no available spots\n      (prisma.parkingSpot.findMany as jest.Mock).mockResolvedValue([]);\n\n      const result = await reservationService.createReservation(validReservationRequest);\n\n      expect(result.success).toBe(true);\n      expect(result.status).toBe('WAITLISTED');\n      expect(result.waitlistPosition).toBeDefined();\n      expect(result.message).toContain('Added to waitlist');\n    });\n\n    it('should return alternatives when spots unavailable and waitlist not allowed', async () => {\n      const noWaitlistRequest = {\n        ...validReservationRequest,\n        allowWaitlist: false\n      };\n\n      // Mock user validation\n      (prisma.user.findUnique as jest.Mock).mockResolvedValue({\n        id: 'user_123',\n        isActive: true\n      });\n\n      // Mock spots with conflicts\n      (prisma.parkingSpot.findMany as jest.Mock).mockResolvedValue([\n        {\n          id: 'spot_123',\n          spotNumber: 'A-101',\n          level: 1,\n          spotType: 'STANDARD',\n          status: 'AVAILABLE',\n          isActive: true,\n          sessions: [{\n            id: 'session_456',\n            status: 'ACTIVE',\n            startTime: new Date('2024-01-20T09:30:00Z'),\n            endTime: new Date('2024-01-20T11:30:00Z')\n          }]\n        }\n      ]);\n\n      // Mock conflict detection\n      (prisma.parkingSession.findMany as jest.Mock).mockResolvedValue([\n        {\n          id: 'session_456',\n          spotId: 'spot_123',\n          status: 'ACTIVE',\n          startTime: new Date('2024-01-20T09:30:00Z'),\n          endTime: new Date('2024-01-20T11:30:00Z'),\n          spot: { id: 'spot_123', spotNumber: 'A-101' }\n        }\n      ]);\n\n      const result = await reservationService.createReservation(noWaitlistRequest);\n\n      expect(result.success).toBe(false);\n      expect(result.status).toBe('CANCELLED');\n      expect(result.message).toContain('No available spots');\n      expect(result.alternativeSpots).toBeDefined();\n    });\n\n    it('should detect time conflicts with existing reservations', async () => {\n      // Mock user validation\n      (prisma.user.findUnique as jest.Mock).mockResolvedValue({\n        id: 'user_123',\n        isActive: true\n      });\n\n      // Mock available spot\n      (prisma.parkingSpot.findMany as jest.Mock).mockResolvedValue([\n        {\n          id: 'spot_123',\n          spotNumber: 'A-101',\n          level: 1,\n          spotType: 'STANDARD',\n          status: 'AVAILABLE',\n          isActive: true,\n          sessions: []\n        }\n      ]);\n\n      // Mock conflicting reservation with high severity\n      (prisma.parkingSession.findMany as jest.Mock).mockResolvedValue([\n        {\n          id: 'session_existing',\n          spotId: 'spot_123',\n          status: 'ACTIVE',\n          startTime: new Date('2024-01-20T09:00:00Z'),\n          endTime: new Date('2024-01-20T13:00:00Z'), // 3-hour overlap\n          spot: { id: 'spot_123', spotNumber: 'A-101' }\n        }\n      ]);\n\n      const result = await reservationService.createReservation(validReservationRequest);\n\n      expect(result.success).toBe(false);\n      expect(result.status).toBe('CANCELLED');\n      expect(result.message).toContain('Time conflict detected');\n    });\n\n    it('should handle specific spot requests', async () => {\n      const specificSpotRequest = {\n        ...validReservationRequest,\n        spotId: 'spot_456'\n      };\n\n      // Mock user validation\n      (prisma.user.findUnique as jest.Mock).mockResolvedValue({\n        id: 'user_123',\n        isActive: true\n      });\n\n      // Mock specific spot availability\n      (prisma.parkingSpot.findUnique as jest.Mock).mockResolvedValue({\n        id: 'spot_456',\n        spotNumber: 'B-205',\n        level: 2,\n        spotType: 'STANDARD',\n        status: 'AVAILABLE',\n        isActive: true,\n        floor: { id: 'floor_2', floorNumber: 2 }\n      });\n\n      // Mock no conflicts\n      (prisma.parkingSession.findMany as jest.Mock).mockResolvedValue([]);\n\n      // Mock transaction\n      const mockReservation = {\n        id: 'reservation_123',\n        startTime: specificSpotRequest.startTime,\n        totalAmount: 10.0,\n        status: 'ACTIVE',\n        vehicle: { id: 'vehicle_123', licensePlate: 'ABC123' },\n        spot: { id: 'spot_456', spotNumber: 'B-205' }\n      };\n\n      (prisma.$transaction as jest.Mock).mockImplementation(async (callback) => {\n        return await callback({\n          parkingSession: {\n            create: jest.fn().mockResolvedValue(mockReservation)\n          },\n          parkingSpot: {\n            update: jest.fn().mockResolvedValue({})\n          }\n        });\n      });\n\n      const result = await reservationService.createReservation(specificSpotRequest);\n\n      expect(result.success).toBe(true);\n      expect(result.spotId).toBe('spot_456');\n      expect(result.message).toContain('B-205');\n    });\n\n    it('should reject inactive or non-existent users', async () => {\n      // Mock inactive user\n      (prisma.user.findUnique as jest.Mock).mockResolvedValue({\n        id: 'user_123',\n        isActive: false\n      });\n\n      const result = await reservationService.createReservation(validReservationRequest);\n\n      expect(result.success).toBe(false);\n      expect(result.status).toBe('CANCELLED');\n      expect(result.message).toContain('Invalid or inactive user');\n    });\n  });\n\n  describe('cancelReservation', () => {\n    const mockReservation = {\n      id: 'reservation_123',\n      spotId: 'spot_123',\n      startTime: new Date('2024-01-20T10:00:00Z'),\n      endTime: new Date('2024-01-20T12:00:00Z'),\n      totalAmount: 10.0,\n      status: 'ACTIVE',\n      vehicle: {\n        id: 'vehicle_123',\n        ownerId: 'user_123',\n        licensePlate: 'ABC123'\n      },\n      spot: {\n        id: 'spot_123',\n        spotNumber: 'A-101'\n      }\n    };\n\n    it('should successfully cancel a reservation with full refund', async () => {\n      // Mock reservation more than 2 hours before start time\n      const earlyReservation = {\n        ...mockReservation,\n        startTime: new Date(Date.now() + 4 * 60 * 60 * 1000) // 4 hours from now\n      };\n\n      (prisma.parkingSession.findUnique as jest.Mock).mockResolvedValue(earlyReservation);\n\n      (prisma.$transaction as jest.Mock).mockImplementation(async (callback) => {\n        return await callback({\n          parkingSession: {\n            update: jest.fn().mockResolvedValue({})\n          },\n          parkingSpot: {\n            update: jest.fn().mockResolvedValue({})\n          }\n        });\n      });\n\n      const result = await reservationService.cancelReservation('reservation_123', 'user_123', 'User request');\n\n      expect(result.success).toBe(true);\n      expect(result.refundAmount).toBe(10.0); // Full refund\n      expect(result.message).toContain('cancelled successfully');\n    });\n\n    it('should cancel with partial refund when within 2 hours of start time', async () => {\n      // Mock reservation 1 hour before start time\n      const lateReservation = {\n        ...mockReservation,\n        startTime: new Date(Date.now() + 1 * 60 * 60 * 1000) // 1 hour from now\n      };\n\n      (prisma.parkingSession.findUnique as jest.Mock).mockResolvedValue(lateReservation);\n\n      (prisma.$transaction as jest.Mock).mockImplementation(async (callback) => {\n        return await callback({\n          parkingSession: {\n            update: jest.fn().mockResolvedValue({})\n          },\n          parkingSpot: {\n            update: jest.fn().mockResolvedValue({})\n          }\n        });\n      });\n\n      const result = await reservationService.cancelReservation('reservation_123', 'user_123', 'User request');\n\n      expect(result.success).toBe(true);\n      expect(result.refundAmount).toBe(5.0); // 50% refund\n    });\n\n    it('should cancel with no refund after start time', async () => {\n      // Mock reservation that has already started\n      const startedReservation = {\n        ...mockReservation,\n        startTime: new Date(Date.now() - 1 * 60 * 60 * 1000) // 1 hour ago\n      };\n\n      (prisma.parkingSession.findUnique as jest.Mock).mockResolvedValue(startedReservation);\n\n      (prisma.$transaction as jest.Mock).mockImplementation(async (callback) => {\n        return await callback({\n          parkingSession: {\n            update: jest.fn().mockResolvedValue({})\n          },\n          parkingSpot: {\n            update: jest.fn().mockResolvedValue({})\n          }\n        });\n      });\n\n      const result = await reservationService.cancelReservation('reservation_123', 'user_123', 'User request');\n\n      expect(result.success).toBe(true);\n      expect(result.refundAmount).toBe(0); // No refund\n    });\n\n    it('should reject cancellation of non-existent reservation', async () => {\n      (prisma.parkingSession.findUnique as jest.Mock).mockResolvedValue(null);\n\n      const result = await reservationService.cancelReservation('nonexistent', 'user_123');\n\n      expect(result.success).toBe(false);\n      expect(result.message).toBe('Reservation not found');\n    });\n\n    it('should reject unauthorized cancellation attempts', async () => {\n      (prisma.parkingSession.findUnique as jest.Mock).mockResolvedValue(mockReservation);\n\n      const result = await reservationService.cancelReservation('reservation_123', 'wrong_user');\n\n      expect(result.success).toBe(false);\n      expect(result.message).toBe('Unauthorized to cancel this reservation');\n    });\n\n    it('should reject cancellation of already cancelled reservations', async () => {\n      const cancelledReservation = {\n        ...mockReservation,\n        status: 'CANCELLED'\n      };\n\n      (prisma.parkingSession.findUnique as jest.Mock).mockResolvedValue(cancelledReservation);\n\n      const result = await reservationService.cancelReservation('reservation_123', 'user_123');\n\n      expect(result.success).toBe(false);\n      expect(result.message).toBe('Reservation cannot be cancelled');\n    });\n\n    it('should reject cancellation of completed reservations', async () => {\n      const completedReservation = {\n        ...mockReservation,\n        status: 'COMPLETED'\n      };\n\n      (prisma.parkingSession.findUnique as jest.Mock).mockResolvedValue(completedReservation);\n\n      const result = await reservationService.cancelReservation('reservation_123', 'user_123');\n\n      expect(result.success).toBe(false);\n      expect(result.message).toBe('Reservation cannot be cancelled');\n    });\n  });\n\n  describe('getUserReservations', () => {\n    it('should return user reservations with correct mapping', async () => {\n      const mockSessions = [\n        {\n          id: 'session_1',\n          startTime: new Date('2024-01-20T10:00:00Z'),\n          endTime: new Date('2024-01-20T12:00:00Z'),\n          status: 'ACTIVE',\n          totalAmount: 10.0,\n          amountPaid: 0,\n          notes: 'Meeting parking',\n          createdAt: new Date('2024-01-19T15:00:00Z'),\n          updatedAt: new Date('2024-01-19T15:00:00Z'),\n          duration: 120,\n          spotId: 'spot_123',\n          vehicle: {\n            ownerId: 'user_123',\n            licensePlate: 'ABC123'\n          },\n          spot: {\n            spotNumber: 'A-101'\n          }\n        }\n      ];\n\n      (prisma.parkingSession.findMany as jest.Mock).mockResolvedValue(mockSessions);\n\n      const reservations = await reservationService.getUserReservations('user_123');\n\n      expect(reservations).toHaveLength(1);\n      expect(reservations[0]).toMatchObject({\n        id: 'session_1',\n        userId: 'user_123',\n        spotId: 'spot_123',\n        spotNumber: 'A-101',\n        vehiclePlate: 'ABC123',\n        status: 'ACTIVE',\n        estimatedCost: 10.0,\n        actualCost: 0,\n        notes: 'Meeting parking'\n      });\n      expect(reservations[0].cancellationDeadline).toBeInstanceOf(Date);\n    });\n\n    it('should filter reservations by status', async () => {\n      (prisma.parkingSession.findMany as jest.Mock).mockResolvedValue([]);\n\n      await reservationService.getUserReservations('user_123', 'ACTIVE');\n\n      expect(prisma.parkingSession.findMany).toHaveBeenCalledWith({\n        where: {\n          vehicle: { ownerId: 'user_123' },\n          status: 'ACTIVE'\n        },\n        include: {\n          vehicle: true,\n          spot: true\n        },\n        orderBy: { startTime: 'desc' }\n      });\n    });\n\n    it('should return empty array for user with no reservations', async () => {\n      (prisma.parkingSession.findMany as jest.Mock).mockResolvedValue([]);\n\n      const reservations = await reservationService.getUserReservations('user_no_reservations');\n\n      expect(reservations).toEqual([]);\n    });\n  });\n\n  describe('getReservationStats', () => {\n    it('should calculate reservation statistics correctly', async () => {\n      // Mock various counts and aggregations\n      (prisma.parkingSession.count as jest.Mock)\n        .mockResolvedValueOnce(150) // total\n        .mockResolvedValueOnce(45)  // active\n        .mockResolvedValueOnce(80)  // completed\n        .mockResolvedValueOnce(20); // cancelled\n\n      (prisma.parkingSession.aggregate as jest.Mock)\n        .mockResolvedValueOnce({ _sum: { amountPaid: 2400.0 } }) // revenue\n        .mockResolvedValueOnce({ _avg: { duration: 135 } }); // avg duration\n\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(200) // total spots\n        .mockResolvedValueOnce(120); // occupied spots\n\n      const stats = await reservationService.getReservationStats('day');\n\n      expect(stats.totalReservations).toBe(150);\n      expect(stats.activeReservations).toBe(45);\n      expect(stats.completedReservations).toBe(80);\n      expect(stats.cancelledReservations).toBe(20);\n      expect(stats.noShowReservations).toBe(5); // 150 - 45 - 80 - 20\n      expect(stats.averageReservationDuration).toBe(135);\n      expect(stats.occupancyRate).toBe(60); // 120/200 * 100\n      expect(stats.revenue).toBe(2400.0);\n    });\n\n    it('should handle zero reservations scenario', async () => {\n      (prisma.parkingSession.count as jest.Mock)\n        .mockResolvedValue(0);\n\n      (prisma.parkingSession.aggregate as jest.Mock)\n        .mockResolvedValueOnce({ _sum: { amountPaid: null } })\n        .mockResolvedValueOnce({ _avg: { duration: null } });\n\n      (prisma.parkingSpot.count as jest.Mock)\n        .mockResolvedValueOnce(100)\n        .mockResolvedValueOnce(0);\n\n      const stats = await reservationService.getReservationStats('day');\n\n      expect(stats.totalReservations).toBe(0);\n      expect(stats.revenue).toBe(0);\n      expect(stats.averageReservationDuration).toBe(0);\n      expect(stats.occupancyRate).toBe(0);\n    });\n  });\n\n  describe('auto-cleanup functionality', () => {\n    it('should be tested with integration tests', () => {\n      // Note: Auto-cleanup runs on intervals and would be better tested\n      // with integration tests that can control timing\n      expect(reservationService).toBeDefined();\n    });\n  });\n\n  describe('error handling', () => {\n    it('should handle database errors gracefully', async () => {\n      (prisma.user.findUnique as jest.Mock).mockRejectedValue(new Error('Database connection failed'));\n\n      const result = await reservationService.createReservation(validReservationRequest);\n\n      expect(result.success).toBe(false);\n      expect(result.status).toBe('CANCELLED');\n      expect(result.message).toBe('Failed to create reservation');\n    });\n\n    it('should handle transaction failures', async () => {\n      // Mock successful validation but transaction failure\n      (prisma.user.findUnique as jest.Mock).mockResolvedValue({\n        id: 'user_123',\n        isActive: true\n      });\n\n      (prisma.parkingSpot.findMany as jest.Mock).mockResolvedValue([\n        {\n          id: 'spot_123',\n          spotNumber: 'A-101',\n          level: 1,\n          spotType: 'STANDARD',\n          status: 'AVAILABLE',\n          isActive: true,\n          sessions: []\n        }\n      ]);\n\n      (prisma.parkingSession.findMany as jest.Mock).mockResolvedValue([]);\n\n      (prisma.$transaction as jest.Mock).mockRejectedValue(new Error('Transaction failed'));\n\n      const result = await reservationService.createReservation(validReservationRequest);\n\n      expect(result.success).toBe(false);\n      expect(result.status).toBe('CANCELLED');\n    });\n\n    it('should handle cancellation errors gracefully', async () => {\n      (prisma.parkingSession.findUnique as jest.Mock).mockResolvedValue(mockReservation);\n      (prisma.$transaction as jest.Mock).mockRejectedValue(new Error('Update failed'));\n\n      const result = await reservationService.cancelReservation('reservation_123', 'user_123');\n\n      expect(result.success).toBe(false);\n      expect(result.message).toBe('Failed to cancel reservation');\n    });\n  });\n});