/**\n * Tests for monitoring configuration and functionality\n * \n * @module MonitoringTests\n */\n\nimport { MonitoringConfig, MetricsCollector, DatabaseHealthCheck, MemoryHealthCheck, SystemHealthCheck } from '../../src/config/monitoring.config';\nimport { performance } from 'perf_hooks';\n\ndescribe('MonitoringConfig', () => {\n  let monitoring: MonitoringConfig;\n  \n  beforeEach(() => {\n    monitoring = MonitoringConfig.getInstance();\n  });\n  \n  describe('getInstance', () => {\n    it('should return singleton instance', () => {\n      const instance1 = MonitoringConfig.getInstance();\n      const instance2 = MonitoringConfig.getInstance();\n      expect(instance1).toBe(instance2);\n    });\n  });\n  \n  describe('getMetricsCollector', () => {\n    it('should return metrics collector instance', () => {\n      const collector = monitoring.getMetricsCollector();\n      expect(collector).toBeInstanceOf(MetricsCollector);\n    });\n  });\n  \n  describe('runHealthChecks', () => {\n    it('should run all health checks', async () => {\n      const results = await monitoring.runHealthChecks();\n      \n      expect(Array.isArray(results)).toBe(true);\n      expect(results.length).toBeGreaterThan(0);\n      \n      results.forEach(result => {\n        expect(result).toHaveProperty('name');\n        expect(result).toHaveProperty('status');\n        expect(['healthy', 'unhealthy', 'degraded']).toContain(result.status);\n      });\n    });\n    \n    it('should include database health check', async () => {\n      const results = await monitoring.runHealthChecks();\n      const dbCheck = results.find(r => r.name === 'database');\n      \n      expect(dbCheck).toBeDefined();\n      expect(dbCheck?.duration).toBeGreaterThan(0);\n    });\n    \n    it('should include memory health check', async () => {\n      const results = await monitoring.runHealthChecks();\n      const memoryCheck = results.find(r => r.name === 'memory');\n      \n      expect(memoryCheck).toBeDefined();\n      expect(memoryCheck?.metadata).toHaveProperty('usagePercent');\n    });\n    \n    it('should include system health check', async () => {\n      const results = await monitoring.runHealthChecks();\n      const systemCheck = results.find(r => r.name === 'system');\n      \n      expect(systemCheck).toBeDefined();\n      expect(systemCheck?.metadata).toHaveProperty('uptime');\n    });\n  });\n  \n  describe('getHealthStatus', () => {\n    it('should return overall health status', async () => {\n      const healthStatus = await monitoring.getHealthStatus();\n      \n      expect(healthStatus).toHaveProperty('status');\n      expect(healthStatus).toHaveProperty('checks');\n      expect(['healthy', 'unhealthy', 'degraded']).toContain(healthStatus.status);\n      expect(Array.isArray(healthStatus.checks)).toBe(true);\n    });\n    \n    it('should return unhealthy if any check fails', async () => {\n      // Add a failing health check\n      monitoring.addHealthCheck({\n        name: 'test-failing',\n        async check() {\n          return {\n            name: 'test-failing',\n            status: 'unhealthy',\n            message: 'Test failure',\n          };\n        },\n      });\n      \n      const healthStatus = await monitoring.getHealthStatus();\n      expect(healthStatus.status).toBe('unhealthy');\n    });\n    \n    it('should return degraded if any check is degraded but none unhealthy', async () => {\n      // Clear existing checks and add specific ones\n      const originalChecks = (monitoring as any).healthChecks;\n      (monitoring as any).healthChecks = [];\n      \n      monitoring.addHealthCheck({\n        name: 'test-healthy',\n        async check() {\n          return {\n            name: 'test-healthy',\n            status: 'healthy',\n            message: 'All good',\n          };\n        },\n      });\n      \n      monitoring.addHealthCheck({\n        name: 'test-degraded',\n        async check() {\n          return {\n            name: 'test-degraded',\n            status: 'degraded',\n            message: 'Some issues',\n          };\n        },\n      });\n      \n      const healthStatus = await monitoring.getHealthStatus();\n      expect(healthStatus.status).toBe('degraded');\n      \n      // Restore original checks\n      (monitoring as any).healthChecks = originalChecks;\n    });\n  });\n  \n  describe('reportError', () => {\n    it('should report error without throwing', () => {\n      const error = new Error('Test error');\n      const context = { userId: '123', operation: 'test' };\n      \n      expect(() => {\n        monitoring.reportError(error, context);\n      }).not.toThrow();\n    });\n  });\n  \n  describe('reportEvent', () => {\n    it('should report event without throwing', () => {\n      const eventName = 'user.login';\n      const eventData = { userId: '123', ip: '127.0.0.1' };\n      \n      expect(() => {\n        monitoring.reportEvent(eventName, eventData);\n      }).not.toThrow();\n    });\n  });\n});\n\ndescribe('MetricsCollector', () => {\n  let collector: MetricsCollector;\n  \n  beforeEach(() => {\n    collector = new MetricsCollector();\n  });\n  \n  describe('record', () => {\n    it('should record a metric', () => {\n      collector.record('test.metric', 42, 'count');\n      \n      const metrics = collector.getMetrics();\n      expect(metrics).toHaveLength(1);\n      expect(metrics[0]).toMatchObject({\n        name: 'test.metric',\n        value: 42,\n        unit: 'count',\n      });\n    });\n    \n    it('should record metric with tags', () => {\n      const tags = { userId: '123', endpoint: '/api/test' };\n      collector.record('http.requests', 1, 'count', tags);\n      \n      const metrics = collector.getMetrics();\n      expect(metrics[0].tags).toEqual(tags);\n    });\n    \n    it('should limit metrics to 1000 entries', () => {\n      // Record 1500 metrics\n      for (let i = 0; i < 1500; i++) {\n        collector.record(`metric.${i}`, i, 'count');\n      }\n      \n      const metrics = collector.getMetrics();\n      expect(metrics).toHaveLength(1000);\n      \n      // Should keep the most recent 1000\n      expect(metrics[0].name).toBe('metric.500');\n      expect(metrics[999].name).toBe('metric.1499');\n    });\n  });\n  \n  describe('increment', () => {\n    it('should increment counter', () => {\n      collector.increment('test.counter');\n      collector.increment('test.counter');\n      collector.increment('test.counter', undefined, 3);\n      \n      expect(collector.getCounter('test.counter')).toBe(6);\n    });\n    \n    it('should increment with tags', () => {\n      const tags = { status: 'success' };\n      collector.increment('requests.total', tags, 5);\n      \n      const metrics = collector.getMetrics();\n      const metric = metrics.find(m => m.name === 'requests.total');\n      expect(metric?.value).toBe(5);\n      expect(metric?.tags).toEqual(tags);\n    });\n  });\n  \n  describe('histogram', () => {\n    it('should record histogram values', () => {\n      collector.histogram('response.time', 100);\n      collector.histogram('response.time', 200);\n      collector.histogram('response.time', 150);\n      \n      const stats = collector.getHistogramStats('response.time');\n      expect(stats.count).toBe(3);\n      expect(stats.min).toBe(100);\n      expect(stats.max).toBe(200);\n      expect(stats.avg).toBe(150);\n    });\n    \n    it('should limit histogram to 100 values', () => {\n      // Record 150 values\n      for (let i = 0; i < 150; i++) {\n        collector.histogram('test.histogram', i);\n      }\n      \n      const stats = collector.getHistogramStats('test.histogram');\n      expect(stats.count).toBe(100);\n    });\n    \n    it('should return empty stats for unknown histogram', () => {\n      const stats = collector.getHistogramStats('unknown');\n      expect(stats).toEqual({\n        count: 0,\n        min: 0,\n        max: 0,\n        avg: 0,\n      });\n    });\n  });\n  \n  describe('timer', () => {\n    it('should measure timing', () => {\n      collector.startTimer('test.operation');\n      \n      // Simulate some work\n      const start = performance.now();\n      while (performance.now() - start < 10) {\n        // Busy wait for ~10ms\n      }\n      \n      const duration = collector.endTimer('test.operation');\n      expect(duration).toBeGreaterThan(5); // Should be at least 5ms\n      expect(duration).toBeLessThan(100); // Should be less than 100ms\n    });\n    \n    it('should handle missing timer gracefully', () => {\n      const duration = collector.endTimer('nonexistent');\n      expect(duration).toBe(0);\n    });\n    \n    it('should record timer in histogram', () => {\n      collector.startTimer('api.request');\n      \n      // Simulate work\n      const start = performance.now();\n      while (performance.now() - start < 5) {}\n      \n      collector.endTimer('api.request', { endpoint: '/test' });\n      \n      const stats = collector.getHistogramStats('api.request');\n      expect(stats.count).toBe(1);\n      expect(stats.avg).toBeGreaterThan(0);\n    });\n  });\n  \n  describe('clear', () => {\n    it('should clear all metrics', () => {\n      collector.record('test.metric', 42);\n      collector.increment('test.counter', undefined, 5);\n      collector.histogram('test.histogram', 100);\n      collector.startTimer('test.timer');\n      \n      collector.clear();\n      \n      expect(collector.getMetrics()).toHaveLength(0);\n      expect(collector.getCounter('test.counter')).toBe(0);\n      expect(collector.getHistogramStats('test.histogram').count).toBe(0);\n      expect(collector.endTimer('test.timer')).toBe(0);\n    });\n  });\n});\n\ndescribe('Health Checks', () => {\n  describe('DatabaseHealthCheck', () => {\n    let healthCheck: DatabaseHealthCheck;\n    \n    beforeEach(() => {\n      healthCheck = new DatabaseHealthCheck();\n    });\n    \n    it('should have correct name', () => {\n      expect(healthCheck.name).toBe('database');\n    });\n    \n    it('should return health check result', async () => {\n      const result = await healthCheck.check();\n      \n      expect(result).toHaveProperty('name', 'database');\n      expect(result).toHaveProperty('status');\n      expect(result).toHaveProperty('duration');\n      expect(['healthy', 'unhealthy', 'degraded']).toContain(result.status);\n      expect(typeof result.duration).toBe('number');\n    });\n    \n    it('should measure check duration', async () => {\n      const result = await healthCheck.check();\n      expect(result.duration).toBeGreaterThan(0);\n    });\n  });\n  \n  describe('MemoryHealthCheck', () => {\n    let healthCheck: MemoryHealthCheck;\n    \n    beforeEach(() => {\n      healthCheck = new MemoryHealthCheck();\n    });\n    \n    it('should have correct name', () => {\n      expect(healthCheck.name).toBe('memory');\n    });\n    \n    it('should return memory health status', async () => {\n      const result = await healthCheck.check();\n      \n      expect(result).toHaveProperty('name', 'memory');\n      expect(result).toHaveProperty('status');\n      expect(result).toHaveProperty('message');\n      expect(result).toHaveProperty('metadata');\n      \n      expect(result.metadata).toHaveProperty('heapUsed');\n      expect(result.metadata).toHaveProperty('heapTotal');\n      expect(result.metadata).toHaveProperty('usagePercent');\n    });\n    \n    it('should calculate memory usage percentage', async () => {\n      const result = await healthCheck.check();\n      const usagePercent = result.metadata?.usagePercent as number;\n      \n      expect(usagePercent).toBeGreaterThan(0);\n      expect(usagePercent).toBeLessThanOrEqual(100);\n    });\n  });\n  \n  describe('SystemHealthCheck', () => {\n    let healthCheck: SystemHealthCheck;\n    \n    beforeEach(() => {\n      healthCheck = new SystemHealthCheck();\n    });\n    \n    it('should have correct name', () => {\n      expect(healthCheck.name).toBe('system');\n    });\n    \n    it('should return system health status', async () => {\n      const result = await healthCheck.check();\n      \n      expect(result).toHaveProperty('name', 'system');\n      expect(result).toHaveProperty('status', 'healthy');\n      expect(result).toHaveProperty('message');\n      expect(result).toHaveProperty('metadata');\n      \n      expect(result.metadata).toHaveProperty('uptime');\n      expect(result.metadata).toHaveProperty('loadAverage');\n      expect(result.metadata).toHaveProperty('cpuUsage');\n      expect(result.metadata).toHaveProperty('nodeVersion');\n      expect(result.metadata).toHaveProperty('platform');\n    });\n    \n    it('should include system information', async () => {\n      const result = await healthCheck.check();\n      const metadata = result.metadata!;\n      \n      expect(typeof metadata.uptime).toBe('number');\n      expect(Array.isArray(metadata.loadAverage)).toBe(true);\n      expect(typeof metadata.nodeVersion).toBe('string');\n      expect(typeof metadata.platform).toBe('string');\n    });\n  });\n});\n\ndescribe('Utility Functions', () => {\n  let collector: MetricsCollector;\n  \n  beforeEach(() => {\n    const monitoring = MonitoringConfig.getInstance();\n    collector = monitoring.getMetricsCollector();\n    collector.clear();\n  });\n  \n  it('should record metric via utility function', () => {\n    const { recordMetric } = require('../../src/config/monitoring.config');\n    recordMetric('test.metric', 100, 'bytes');\n    \n    const metrics = collector.getMetrics();\n    expect(metrics).toHaveLength(1);\n    expect(metrics[0].name).toBe('test.metric');\n  });\n  \n  it('should increment counter via utility function', () => {\n    const { incrementCounter } = require('../../src/config/monitoring.config');\n    incrementCounter('test.counter', { status: 'success' }, 5);\n    \n    expect(collector.getCounter('test.counter')).toBe(5);\n  });\n  \n  it('should time operation via utility functions', () => {\n    const { startTimer, endTimer } = require('../../src/config/monitoring.config');\n    \n    startTimer('test.operation');\n    const duration = endTimer('test.operation');\n    \n    expect(duration).toBeGreaterThan(0);\n  });\n});