import request from 'supertest';
import app from '../../src/app';
import { prisma } from '../../src/config/database';
import authService from '../../src/services/authService';
import { sessionManager } from '../../src/services/SessionManager';
import { HTTP_STATUS, API_RESPONSES } from '../../src/config/constants';
import * as crypto from 'crypto';

/**
 * Comprehensive Authentication System Tests
 * Tests all authentication features including JWT tokens, password security, 
 * RBAC, session management, and security middleware.
 */
describe('Authentication System', () => {
  let testUser: any;
  let authToken: string;
  let refreshToken: string;

  beforeAll(async () => {
    // Clean up test database
    await prisma.userSession.deleteMany({});
    await prisma.user.deleteMany({});
  });

  afterAll(async () => {
    // Clean up test database
    await prisma.userSession.deleteMany({});
    await prisma.user.deleteMany({});
    await sessionManager.close();
    await prisma.$disconnect();
  });

  beforeEach(async () => {
    // Clean up before each test
    await prisma.userSession.deleteMany({});
    await prisma.user.deleteMany({});
  });

  describe('User Registration (Signup)', () => {
    test('should register a new user with valid data', async () => {
      const userData = {\n        email: 'test@example.com',\n        password: 'SecurePass123!',\n        firstName: 'Test',\n        lastName: 'User'\n      };\n\n      const response = await request(app)\n        .post('/api/auth/signup')\n        .send(userData)\n        .expect(HTTP_STATUS.CREATED);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.user).toBeDefined();\n      expect(response.body.data.user.email).toBe(userData.email);\n      expect(response.body.data.user.passwordHash).toBeUndefined();\n      expect(response.body.data.token).toBeDefined();\n      expect(response.body.data.refreshToken).toBeDefined();\n\n      // Verify user was created in database\n      const dbUser = await prisma.user.findUnique({\n        where: { email: userData.email }\n      });\n      expect(dbUser).toBeTruthy();\n      expect(dbUser!.role).toBe('USER');\n      expect(dbUser!.isActive).toBe(true);\n    });\n\n    test('should reject registration with weak password', async () => {\n      const userData = {\n        email: 'test@example.com',\n        password: '123', // Too weak\n        firstName: 'Test',\n        lastName: 'User'\n      };\n\n      const response = await request(app)\n        .post('/api/auth/signup')\n        .send(userData)\n        .expect(HTTP_STATUS.BAD_REQUEST);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.errors).toBeDefined();\n    });\n\n    test('should reject registration with duplicate email', async () => {\n      const userData = {\n        email: 'test@example.com',\n        password: 'SecurePass123!',\n        firstName: 'Test',\n        lastName: 'User'\n      };\n\n      // First registration should succeed\n      await request(app)\n        .post('/api/auth/signup')\n        .send(userData)\n        .expect(HTTP_STATUS.CREATED);\n\n      // Second registration with same email should fail\n      const response = await request(app)\n        .post('/api/auth/signup')\n        .send(userData)\n        .expect(HTTP_STATUS.BAD_REQUEST);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.message).toBe(API_RESPONSES.ERRORS.USER_EXISTS);\n    });\n\n    test('should enforce signup rate limiting', async () => {\n      const userData = {\n        email: 'test@example.com',\n        password: 'SecurePass123!',\n        firstName: 'Test',\n        lastName: 'User'\n      };\n\n      // Make multiple rapid signup attempts\n      const promises = Array(6).fill(0).map((_, index) => \n        request(app)\n          .post('/api/auth/signup')\n          .send({ ...userData, email: `test${index}@example.com` })\n      );\n\n      const responses = await Promise.all(promises);\n      \n      // Some requests should be rate limited\n      const rateLimitedResponses = responses.filter(r => r.status === HTTP_STATUS.TOO_MANY_REQUESTS);\n      expect(rateLimitedResponses.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('User Login', () => {\n    beforeEach(async () => {\n      // Create test user\n      const result = await authService.signup({\n        email: 'test@example.com',\n        password: 'SecurePass123!',\n        firstName: 'Test',\n        lastName: 'User'\n      });\n      testUser = result.user;\n    });\n\n    test('should login with valid credentials', async () => {\n      const loginData = {\n        email: 'test@example.com',\n        password: 'SecurePass123!'\n      };\n\n      const response = await request(app)\n        .post('/api/auth/login')\n        .send(loginData)\n        .expect(HTTP_STATUS.OK);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.user).toBeDefined();\n      expect(response.body.data.token).toBeDefined();\n      expect(response.body.data.refreshToken).toBeDefined();\n      expect(response.body.data.user.passwordHash).toBeUndefined();\n\n      authToken = response.body.data.token;\n      refreshToken = response.body.data.refreshToken;\n\n      // Verify session was created\n      const sessions = await sessionManager.getUserSessions(testUser.id);\n      expect(sessions.length).toBe(1);\n    });\n\n    test('should reject login with invalid credentials', async () => {\n      const loginData = {\n        email: 'test@example.com',\n        password: 'WrongPassword123!'\n      };\n\n      const response = await request(app)\n        .post('/api/auth/login')\n        .send(loginData)\n        .expect(HTTP_STATUS.UNAUTHORIZED);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.message).toBe(API_RESPONSES.ERRORS.INVALID_CREDENTIALS);\n    });\n\n    test('should enforce account lockout after failed attempts', async () => {\n      const loginData = {\n        email: 'test@example.com',\n        password: 'WrongPassword'\n      };\n\n      // Make multiple failed login attempts\n      for (let i = 0; i < 6; i++) {\n        await request(app)\n          .post('/api/auth/login')\n          .send(loginData);\n      }\n\n      // Next attempt should return account locked\n      const response = await request(app)\n        .post('/api/auth/login')\n        .send(loginData)\n        .expect(HTTP_STATUS.UNAUTHORIZED);\n\n      expect(response.body.message).toBe(API_RESPONSES.ERRORS.ACCOUNT_LOCKED);\n    });\n\n    test('should track device information', async () => {\n      const loginData = {\n        email: 'test@example.com',\n        password: 'SecurePass123!'\n      };\n\n      const response = await request(app)\n        .post('/api/auth/login')\n        .set('User-Agent', 'Test-Browser/1.0')\n        .send(loginData)\n        .expect(HTTP_STATUS.OK);\n\n      expect(response.body.success).toBe(true);\n\n      // Verify session contains device info\n      const sessions = await sessionManager.getUserSessions(testUser.id);\n      expect(sessions[0].deviceInfo).toContain('Test-Browser');\n    });\n  });\n\n  describe('JWT Token Management', () => {\n    beforeEach(async () => {\n      // Create test user and login\n      await authService.signup({\n        email: 'test@example.com',\n        password: 'SecurePass123!',\n        firstName: 'Test',\n        lastName: 'User'\n      });\n\n      const loginResponse = await request(app)\n        .post('/api/auth/login')\n        .send({\n          email: 'test@example.com',\n          password: 'SecurePass123!'\n        });\n\n      testUser = loginResponse.body.data.user;\n      authToken = loginResponse.body.data.token;\n      refreshToken = loginResponse.body.data.refreshToken;\n    });\n\n    test('should verify valid JWT token', async () => {\n      const response = await request(app)\n        .get('/api/auth/verify')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(HTTP_STATUS.OK);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.authenticated).toBe(true);\n      expect(response.body.data.user.id).toBe(testUser.id);\n    });\n\n    test('should reject invalid JWT token', async () => {\n      const invalidToken = 'invalid.jwt.token';\n\n      const response = await request(app)\n        .get('/api/auth/verify')\n        .set('Authorization', `Bearer ${invalidToken}`)\n        .expect(HTTP_STATUS.UNAUTHORIZED);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.message).toBe(API_RESPONSES.ERRORS.INVALID_TOKEN);\n    });\n\n    test('should refresh access token with valid refresh token', async () => {\n      const response = await request(app)\n        .post('/api/auth/refresh')\n        .send({ refreshToken })\n        .expect(HTTP_STATUS.OK);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.token).toBeDefined();\n      expect(response.body.data.refreshToken).toBeDefined();\n      expect(response.body.data.token).not.toBe(authToken); // Should be new token\n    });\n\n    test('should reject invalid refresh token', async () => {\n      const invalidRefreshToken = 'invalid.refresh.token';\n\n      const response = await request(app)\n        .post('/api/auth/refresh')\n        .send({ refreshToken: invalidRefreshToken })\n        .expect(HTTP_STATUS.UNAUTHORIZED);\n\n      expect(response.body.success).toBe(false);\n    });\n\n    test('should blacklist token on logout', async () => {\n      // Verify token works initially\n      await request(app)\n        .get('/api/auth/verify')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(HTTP_STATUS.OK);\n\n      // Logout\n      await request(app)\n        .post('/api/auth/logout')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(HTTP_STATUS.OK);\n\n      // Token should now be blacklisted\n      const response = await request(app)\n        .get('/api/auth/verify')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(HTTP_STATUS.UNAUTHORIZED);\n\n      expect(response.body.success).toBe(false);\n    });\n  });\n\n  describe('Password Security', () => {\n    beforeEach(async () => {\n      const result = await authService.signup({\n        email: 'test@example.com',\n        password: 'SecurePass123!',\n        firstName: 'Test',\n        lastName: 'User'\n      });\n      testUser = result.user;\n      authToken = result.token!;\n    });\n\n    test('should validate password strength', async () => {\n      const weakPassword = '123';\n      const strongPassword = 'SecurePass123!';\n\n      // Test weak password\n      const weakResponse = await request(app)\n        .post('/api/auth/validate-password')\n        .send({ password: weakPassword })\n        .expect(HTTP_STATUS.OK);\n\n      expect(weakResponse.body.data.isValid).toBe(false);\n      expect(weakResponse.body.data.errors.length).toBeGreaterThan(0);\n\n      // Test strong password\n      const strongResponse = await request(app)\n        .post('/api/auth/validate-password')\n        .send({ password: strongPassword })\n        .expect(HTTP_STATUS.OK);\n\n      expect(strongResponse.body.data.isValid).toBe(true);\n      expect(strongResponse.body.data.errors.length).toBe(0);\n    });\n\n    test('should change password with valid current password', async () => {\n      const changePasswordData = {\n        currentPassword: 'SecurePass123!',\n        newPassword: 'NewSecurePass456!'\n      };\n\n      const response = await request(app)\n        .put('/api/auth/change-password')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send(changePasswordData)\n        .expect(HTTP_STATUS.OK);\n\n      expect(response.body.success).toBe(true);\n\n      // Verify old password no longer works\n      const loginResponse = await request(app)\n        .post('/api/auth/login')\n        .send({\n          email: 'test@example.com',\n          password: 'SecurePass123!'\n        })\n        .expect(HTTP_STATUS.UNAUTHORIZED);\n\n      expect(loginResponse.body.success).toBe(false);\n\n      // Verify new password works\n      await request(app)\n        .post('/api/auth/login')\n        .send({\n          email: 'test@example.com',\n          password: 'NewSecurePass456!'\n        })\n        .expect(HTTP_STATUS.OK);\n    });\n\n    test('should reject password change with invalid current password', async () => {\n      const changePasswordData = {\n        currentPassword: 'WrongPassword',\n        newPassword: 'NewSecurePass456!'\n      };\n\n      const response = await request(app)\n        .put('/api/auth/change-password')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send(changePasswordData)\n        .expect(HTTP_STATUS.BAD_REQUEST);\n\n      expect(response.body.success).toBe(false);\n    });\n\n    test('should initiate password reset flow', async () => {\n      const response = await request(app)\n        .post('/api/auth/password-reset')\n        .send({ email: 'test@example.com' })\n        .expect(HTTP_STATUS.OK);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.message).toContain('password reset link');\n    });\n\n    test('should handle password reset for non-existent email securely', async () => {\n      // Should not reveal if email exists or not\n      const response = await request(app)\n        .post('/api/auth/password-reset')\n        .send({ email: 'nonexistent@example.com' })\n        .expect(HTTP_STATUS.OK);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.message).toContain('password reset link');\n    });\n  });\n\n  describe('Role-Based Access Control (RBAC)', () => {\n    let adminUser: any;\n    let adminToken: string;\n    let managerUser: any;\n    let managerToken: string;\n    let regularUser: any;\n    let userToken: string;\n\n    beforeEach(async () => {\n      // Create users with different roles\n      const adminResult = await authService.signup({\n        email: 'admin@example.com',\n        password: 'AdminPass123!',\n        firstName: 'Admin',\n        lastName: 'User'\n      });\n      adminUser = adminResult.user;\n      adminToken = adminResult.token!;\n\n      const managerResult = await authService.signup({\n        email: 'manager@example.com',\n        password: 'ManagerPass123!',\n        firstName: 'Manager',\n        lastName: 'User'\n      });\n      managerUser = managerResult.user;\n      managerToken = managerResult.token!;\n\n      const userResult = await authService.signup({\n        email: 'user@example.com',\n        password: 'UserPass123!',\n        firstName: 'Regular',\n        lastName: 'User'\n      });\n      regularUser = userResult.user;\n      userToken = userResult.token!;\n\n      // Update roles in database\n      await prisma.user.update({\n        where: { id: adminUser.id },\n        data: { role: 'ADMIN' }\n      });\n      \n      await prisma.user.update({\n        where: { id: managerUser.id },\n        data: { role: 'MANAGER' }\n      });\n    });\n\n    test('should allow access based on role hierarchy', async () => {\n      // All authenticated users should be able to access their profile\n      await request(app)\n        .get('/api/auth/profile')\n        .set('Authorization', `Bearer ${userToken}`)\n        .expect(HTTP_STATUS.OK);\n\n      await request(app)\n        .get('/api/auth/profile')\n        .set('Authorization', `Bearer ${managerToken}`)\n        .expect(HTTP_STATUS.OK);\n\n      await request(app)\n        .get('/api/auth/profile')\n        .set('Authorization', `Bearer ${adminToken}`)\n        .expect(HTTP_STATUS.OK);\n    });\n\n    test('should enforce role-specific permissions', async () => {\n      // Test role validation utilities\n      const adminUserFromDB = await prisma.user.findUnique({\n        where: { id: adminUser.id }\n      });\n      \n      const managerUserFromDB = await prisma.user.findUnique({\n        where: { id: managerUser.id }\n      });\n      \n      const regularUserFromDB = await prisma.user.findUnique({\n        where: { id: regularUser.id }\n      });\n\n      expect(adminUserFromDB!.role).toBe('ADMIN');\n      expect(managerUserFromDB!.role).toBe('MANAGER');\n      expect(regularUserFromDB!.role).toBe('USER');\n    });\n  });\n\n  describe('Session Management', () => {\n    beforeEach(async () => {\n      const result = await authService.signup({\n        email: 'test@example.com',\n        password: 'SecurePass123!',\n        firstName: 'Test',\n        lastName: 'User'\n      });\n      testUser = result.user;\n      authToken = result.token!;\n    });\n\n    test('should track user sessions', async () => {\n      const response = await request(app)\n        .get('/api/auth/sessions')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(HTTP_STATUS.OK);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.sessions).toBeDefined();\n      expect(response.body.data.sessions.length).toBeGreaterThan(0);\n      expect(response.body.data.totalActiveSessions).toBeGreaterThan(0);\n    });\n\n    test('should logout from all devices', async () => {\n      // Create multiple sessions\n      const session2 = await request(app)\n        .post('/api/auth/login')\n        .send({\n          email: 'test@example.com',\n          password: 'SecurePass123!'\n        })\n        .expect(HTTP_STATUS.OK);\n\n      const token2 = session2.body.data.token;\n\n      // Verify both tokens work\n      await request(app)\n        .get('/api/auth/verify')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(HTTP_STATUS.OK);\n\n      await request(app)\n        .get('/api/auth/verify')\n        .set('Authorization', `Bearer ${token2}`)\n        .expect(HTTP_STATUS.OK);\n\n      // Logout from all devices\n      const logoutResponse = await request(app)\n        .post('/api/auth/logout-all')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(HTTP_STATUS.OK);\n\n      expect(logoutResponse.body.success).toBe(true);\n      expect(logoutResponse.body.data.devicesLoggedOut).toBeGreaterThan(0);\n\n      // Both tokens should now be invalid\n      await request(app)\n        .get('/api/auth/verify')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(HTTP_STATUS.UNAUTHORIZED);\n\n      await request(app)\n        .get('/api/auth/verify')\n        .set('Authorization', `Bearer ${token2}`)\n        .expect(HTTP_STATUS.UNAUTHORIZED);\n    });\n\n    test('should enforce concurrent session limits', async () => {\n      // Create multiple sessions (more than the limit)\n      const sessionTokens = [];\n      \n      for (let i = 0; i < 7; i++) {\n        const loginResponse = await request(app)\n          .post('/api/auth/login')\n          .send({\n            email: 'test@example.com',\n            password: 'SecurePass123!'\n          });\n        \n        if (loginResponse.status === HTTP_STATUS.OK) {\n          sessionTokens.push(loginResponse.body.data.token);\n        }\n      }\n\n      // Should have limited the number of concurrent sessions\n      const activeSessionCount = await authService.getActiveSessionCount(testUser.id);\n      expect(activeSessionCount).toBeLessThanOrEqual(6); // Allow some buffer\n    });\n  });\n\n  describe('Security Middleware', () => {\n    test('should add security headers to responses', async () => {\n      const response = await request(app)\n        .get('/health')\n        .expect(HTTP_STATUS.OK);\n\n      expect(response.headers['x-content-type-options']).toBe('nosniff');\n      expect(response.headers['x-frame-options']).toBe('DENY');\n      expect(response.headers['x-xss-protection']).toBe('1; mode=block');\n    });\n\n    test('should sanitize request inputs', async () => {\n      const maliciousData = {\n        email: 'test@example.com<script>alert(\"xss\")</script>',\n        password: 'SecurePass123!',\n        firstName: 'Test<script>',\n        lastName: 'User'\n      };\n\n      const response = await request(app)\n        .post('/api/auth/signup')\n        .send(maliciousData)\n        .expect(HTTP_STATUS.CREATED);\n\n      // Verify script tags are removed\n      expect(response.body.data.user.email).not.toContain('<script>');\n      expect(response.body.data.user.firstName).not.toContain('<script>');\n    });\n\n    test('should enforce content type validation', async () => {\n      const response = await request(app)\n        .post('/api/auth/login')\n        .set('Content-Type', 'text/plain')\n        .send('invalid content type')\n        .expect(HTTP_STATUS.BAD_REQUEST);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.message).toBe('Invalid content type');\n    });\n\n    test('should detect suspicious activity', async () => {\n      // Make requests with suspicious patterns\n      const suspiciousRequests = [\n        '/api/auth/login?union=select',\n        '/api/auth/login?<script>alert()',\n        '/api/auth/login?../../../etc/passwd'\n      ];\n\n      for (const path of suspiciousRequests) {\n        await request(app)\n          .get(path)\n          .set('User-Agent', '') // Empty user agent is suspicious\n          .expect((res) => {\n            // Should either block or log the suspicious activity\n            // The exact response may vary based on implementation\n          });\n      }\n    });\n  });\n\n  describe('Error Handling and Edge Cases', () => {\n    test('should handle database connection errors gracefully', async () => {\n      // This is a difficult test to implement without actually disconnecting the database\n      // In a real scenario, you might use database mocking\n      expect(true).toBe(true); // Placeholder\n    });\n\n    test('should handle malformed JWT tokens', async () => {\n      const malformedTokens = [\n        'not.a.jwt',\n        'bearer malformed-token',\n        '',\n        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.malformed.signature'\n      ];\n\n      for (const token of malformedTokens) {\n        const response = await request(app)\n          .get('/api/auth/verify')\n          .set('Authorization', `Bearer ${token}`)\n          .expect(HTTP_STATUS.UNAUTHORIZED);\n\n        expect(response.body.success).toBe(false);\n      }\n    });\n\n    test('should handle concurrent login attempts safely', async () => {\n      // Create test user first\n      await authService.signup({\n        email: 'concurrent@example.com',\n        password: 'SecurePass123!',\n        firstName: 'Test',\n        lastName: 'User'\n      });\n\n      // Make concurrent login requests\n      const promises = Array(10).fill(0).map(() =>\n        request(app)\n          .post('/api/auth/login')\n          .send({\n            email: 'concurrent@example.com',\n            password: 'SecurePass123!'\n          })\n      );\n\n      const responses = await Promise.all(promises);\n      \n      // All should either succeed or be rate limited\n      responses.forEach(response => {\n        expect([HTTP_STATUS.OK, HTTP_STATUS.TOO_MANY_REQUESTS]).toContain(response.status);\n      });\n    });\n  });\n\n  describe('Performance and Security Metrics', () => {\n    test('should cleanup expired sessions periodically', async () => {\n      // Create test user\n      const result = await authService.signup({\n        email: 'cleanup@example.com',\n        password: 'SecurePass123!',\n        firstName: 'Test',\n        lastName: 'User'\n      });\n\n      // Create session\n      await sessionManager.createSession('test-session-id', {\n        userId: result.user!.id,\n        userRole: 'USER',\n        userEmail: 'cleanup@example.com',\n        createdAt: Date.now() - (2 * 60 * 60 * 1000), // 2 hours ago\n        lastAccessedAt: Date.now() - (2 * 60 * 60 * 1000),\n        isActive: true\n      });\n\n      // Run cleanup\n      const cleanedCount = await authService.cleanupExpiredSessions();\n      \n      // Should clean up expired sessions\n      expect(cleanedCount).toBeGreaterThanOrEqual(0);\n    });\n\n    test('should provide session statistics', async () => {\n      const stats = await sessionManager.getSessionStats();\n      \n      expect(stats).toBeDefined();\n      expect(stats.storage).toBeDefined();\n      expect(typeof stats.totalSessions).toBe('number');\n      expect(typeof stats.activeSessions).toBe('number');\n    });\n  });\n});\n\n/**\n * Helper function to generate random email for testing\n */\nfunction generateRandomEmail(): string {\n  return `test${Math.random().toString(36).substr(2, 9)}@example.com`;\n}\n\n/**\n * Helper function to create authenticated request headers\n */\nfunction createAuthHeaders(token: string) {\n  return {\n    'Authorization': `Bearer ${token}`,\n    'Content-Type': 'application/json'\n  };\n}