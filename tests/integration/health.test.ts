/**\n * Tests for health check routes\n * \n * @module HealthRoutesTests\n */\n\nimport request from 'supertest';\nimport express from 'express';\nimport healthRoutes from '../../src/routes/health';\nimport { monitoring } from '../../src/config/monitoring.config';\nimport { createMonitoringMiddleware } from '../../src/middleware/monitoring.middleware';\n\n// Create test app\nconst app = express();\napp.use(express.json());\napp.use(...createMonitoringMiddleware());\napp.use('/health', healthRoutes);\n\n// Mock monitoring\njest.mock('../../src/config/monitoring.config');\nconst mockMonitoring = monitoring as jest.Mocked<typeof monitoring>;\n\ndescribe('Health Routes', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  describe('GET /health', () => {\n    it('should return healthy status when all checks pass', async () => {\n      mockMonitoring.getHealthStatus.mockResolvedValue({\n        status: 'healthy',\n        checks: [\n          {\n            name: 'database',\n            status: 'healthy',\n            message: 'Database connection healthy',\n            duration: 50\n          }\n        ]\n      });\n      \n      const response = await request(app)\n        .get('/health')\n        .expect(200);\n      \n      expect(response.body).toMatchObject({\n        status: 'healthy',\n        timestamp: expect.any(String),\n        uptime: expect.any(Number),\n        version: expect.any(String),\n        environment: expect.any(String),\n        duration: expect.any(Number)\n      });\n    });\n    \n    it('should return 503 when system is unhealthy', async () => {\n      mockMonitoring.getHealthStatus.mockResolvedValue({\n        status: 'unhealthy',\n        checks: [\n          {\n            name: 'database',\n            status: 'unhealthy',\n            message: 'Database connection failed',\n            duration: 5000\n          }\n        ]\n      });\n      \n      const response = await request(app)\n        .get('/health')\n        .expect(503);\n      \n      expect(response.body).toMatchObject({\n        status: 'unhealthy',\n        timestamp: expect.any(String),\n        duration: expect.any(Number)\n      });\n    });\n    \n    it('should return 503 when system is degraded', async () => {\n      mockMonitoring.getHealthStatus.mockResolvedValue({\n        status: 'degraded',\n        checks: [\n          {\n            name: 'database',\n            status: 'degraded',\n            message: 'Database connection slow',\n            duration: 2000\n          }\n        ]\n      });\n      \n      const response = await request(app)\n        .get('/health')\n        .expect(503);\n      \n      expect(response.body.status).toBe('degraded');\n    });\n    \n    it('should handle monitoring errors gracefully', async () => {\n      mockMonitoring.getHealthStatus.mockRejectedValue(new Error('Monitoring error'));\n      \n      const response = await request(app)\n        .get('/health')\n        .expect(503);\n      \n      expect(response.body).toMatchObject({\n        status: 'unhealthy',\n        timestamp: expect.any(String),\n        error: 'Monitoring error',\n        duration: expect.any(Number)\n      });\n    });\n    \n    it('should include correlation ID in response headers', async () => {\n      mockMonitoring.getHealthStatus.mockResolvedValue({\n        status: 'healthy',\n        checks: []\n      });\n      \n      const response = await request(app)\n        .get('/health')\n        .expect(200);\n      \n      expect(response.headers['x-correlation-id']).toBeDefined();\n    });\n  });\n  \n  describe('GET /health/detailed', () => {\n    it('should return detailed health information', async () => {\n      const mockHealthStatus = {\n        status: 'healthy' as const,\n        checks: [\n          {\n            name: 'database',\n            status: 'healthy' as const,\n            message: 'Database connection healthy',\n            duration: 50\n          },\n          {\n            name: 'memory',\n            status: 'healthy' as const,\n            message: 'Memory usage normal',\n            duration: 5,\n            metadata: {\n              heapUsed: 50 * 1024 * 1024,\n              heapTotal: 100 * 1024 * 1024,\n              usagePercent: 50\n            }\n          }\n        ]\n      };\n      \n      mockMonitoring.getHealthStatus.mockResolvedValue(mockHealthStatus);\n      \n      const response = await request(app)\n        .get('/health/detailed')\n        .expect(200);\n      \n      expect(response.body).toMatchObject({\n        status: 'healthy',\n        timestamp: expect.any(String),\n        uptime: expect.any(Number),\n        version: expect.any(String),\n        environment: expect.any(String),\n        duration: expect.any(Number),\n        checks: expect.arrayContaining([\n          expect.objectContaining({\n            name: 'database',\n            status: 'healthy'\n          }),\n          expect.objectContaining({\n            name: 'memory',\n            status: 'healthy'\n          })\n        ]),\n        system: expect.objectContaining({\n          memory: expect.objectContaining({\n            used: expect.any(Number),\n            total: expect.any(Number)\n          }),\n          cpu: expect.any(Object),\n          platform: expect.objectContaining({\n            node: expect.any(String),\n            platform: expect.any(String)\n          })\n        }),\n        configuration: expect.objectContaining({\n          logLevel: expect.any(String),\n          metricsEnabled: expect.any(Boolean)\n        })\n      });\n    });\n    \n    it('should return 503 for unhealthy detailed status', async () => {\n      mockMonitoring.getHealthStatus.mockResolvedValue({\n        status: 'unhealthy',\n        checks: [\n          {\n            name: 'database',\n            status: 'unhealthy',\n            message: 'Connection failed'\n          }\n        ]\n      });\n      \n      await request(app)\n        .get('/health/detailed')\n        .expect(503);\n    });\n  });\n  \n  describe('GET /health/ready', () => {\n    it('should return ready status when critical services are healthy', async () => {\n      mockMonitoring.getHealthStatus.mockResolvedValue({\n        status: 'healthy',\n        checks: [\n          {\n            name: 'database',\n            status: 'healthy',\n            message: 'Database ready'\n          },\n          {\n            name: 'memory',\n            status: 'healthy',\n            message: 'Memory OK'\n          }\n        ]\n      });\n      \n      const response = await request(app)\n        .get('/health/ready')\n        .expect(200);\n      \n      expect(response.body).toMatchObject({\n        ready: true,\n        timestamp: expect.any(String),\n        duration: expect.any(Number),\n        checks: expect.arrayContaining([\n          expect.objectContaining({\n            name: 'database',\n            status: 'healthy'\n          })\n        ])\n      });\n    });\n    \n    it('should return not ready when database is unhealthy', async () => {\n      mockMonitoring.getHealthStatus.mockResolvedValue({\n        status: 'unhealthy',\n        checks: [\n          {\n            name: 'database',\n            status: 'unhealthy',\n            message: 'Database connection failed'\n          }\n        ]\n      });\n      \n      const response = await request(app)\n        .get('/health/ready')\n        .expect(503);\n      \n      expect(response.body).toMatchObject({\n        ready: false,\n        timestamp: expect.any(String),\n        duration: expect.any(Number)\n      });\n    });\n    \n    it('should consider degraded database as ready', async () => {\n      mockMonitoring.getHealthStatus.mockResolvedValue({\n        status: 'degraded',\n        checks: [\n          {\n            name: 'database',\n            status: 'degraded',\n            message: 'Database slow but functional'\n          }\n        ]\n      });\n      \n      const response = await request(app)\n        .get('/health/ready')\n        .expect(200);\n      \n      expect(response.body.ready).toBe(true);\n    });\n  });\n  \n  describe('GET /health/live', () => {\n    it('should return alive status when memory usage is normal', async () => {\n      const response = await request(app)\n        .get('/health/live')\n        .expect(200);\n      \n      expect(response.body).toMatchObject({\n        alive: true,\n        timestamp: expect.any(String),\n        uptime: expect.any(Number),\n        duration: expect.any(Number),\n        memory: expect.objectContaining({\n          used: expect.any(Number),\n          total: expect.any(Number),\n          percent: expect.any(Number)\n        })\n      });\n      \n      expect(response.body.memory.percent).toBeLessThan(95);\n    });\n    \n    it('should handle liveness check errors', async () => {\n      // Mock process.memoryUsage to throw an error\n      const originalMemoryUsage = process.memoryUsage;\n      process.memoryUsage = jest.fn().mockImplementation(() => {\n        throw new Error('Memory check failed');\n      });\n      \n      const response = await request(app)\n        .get('/health/live')\n        .expect(503);\n      \n      expect(response.body).toMatchObject({\n        alive: false,\n        timestamp: expect.any(String),\n        error: 'Memory check failed'\n      });\n      \n      // Restore original function\n      process.memoryUsage = originalMemoryUsage;\n    });\n  });\n  \n  describe('GET /health/metrics', () => {\n    it('should return metrics in Prometheus format', async () => {\n      const mockMetrics = [\n        {\n          name: 'http.requests.total',\n          value: 100,\n          unit: 'count',\n          tags: { method: 'GET', status: '200' },\n          timestamp: new Date()\n        },\n        {\n          name: 'response.time',\n          value: 150,\n          unit: 'ms',\n          tags: undefined,\n          timestamp: new Date()\n        }\n      ];\n      \n      const mockCollector = {\n        getMetrics: jest.fn().mockReturnValue(mockMetrics)\n      };\n      \n      mockMonitoring.getMetricsCollector.mockReturnValue(mockCollector as any);\n      \n      const response = await request(app)\n        .get('/health/metrics')\n        .expect(200)\n        .expect('Content-Type', /text\\/plain/);\n      \n      // Should contain Prometheus format metrics\n      expect(response.text).toContain('# HELP http_requests_total');\n      expect(response.text).toContain('# TYPE http_requests_total');\n      expect(response.text).toContain('http_requests_total{method=\"GET\",status=\"200\"} 100');\n      expect(response.text).toContain('response_time 150');\n      \n      // Should contain system metrics\n      expect(response.text).toContain('nodejs_memory_heap_used_bytes');\n      expect(response.text).toContain('nodejs_uptime_seconds');\n    });\n    \n    it('should handle metrics collection errors', async () => {\n      mockMonitoring.getMetricsCollector.mockImplementation(() => {\n        throw new Error('Metrics collection failed');\n      });\n      \n      const response = await request(app)\n        .get('/health/metrics')\n        .expect(500);\n      \n      expect(response.body).toMatchObject({\n        error: 'Failed to generate metrics',\n        message: 'Metrics collection failed'\n      });\n    });\n    \n    it('should sanitize metric names for Prometheus format', async () => {\n      const mockMetrics = [\n        {\n          name: 'http.requests-total@count',\n          value: 42,\n          unit: 'count',\n          tags: undefined,\n          timestamp: new Date()\n        }\n      ];\n      \n      const mockCollector = {\n        getMetrics: jest.fn().mockReturnValue(mockMetrics)\n      };\n      \n      mockMonitoring.getMetricsCollector.mockReturnValue(mockCollector as any);\n      \n      const response = await request(app)\n        .get('/health/metrics')\n        .expect(200);\n      \n      // Should sanitize metric name\n      expect(response.text).toContain('http_requests_total_count 42');\n    });\n  });\n  \n  describe('GET /health/debug', () => {\n    it('should return debug information in development', async () => {\n      const originalEnv = process.env.NODE_ENV;\n      process.env.NODE_ENV = 'development';\n      \n      const mockMetrics = [\n        {\n          name: 'test.metric',\n          value: 123,\n          unit: 'count',\n          tags: undefined,\n          timestamp: new Date()\n        }\n      ];\n      \n      const mockCollector = {\n        getMetrics: jest.fn().mockReturnValue(mockMetrics)\n      };\n      \n      mockMonitoring.getMetricsCollector.mockReturnValue(mockCollector as any);\n      \n      const response = await request(app)\n        .get('/health/debug')\n        .expect(200);\n      \n      expect(response.body).toMatchObject({\n        timestamp: expect.any(String),\n        environment: 'development',\n        configuration: expect.any(Object),\n        metrics: expect.objectContaining({\n          total: 1,\n          recent: expect.any(Array)\n        }),\n        process: expect.objectContaining({\n          pid: expect.any(Number),\n          version: expect.any(String),\n          uptime: expect.any(Number)\n        }),\n        request: expect.objectContaining({\n          correlationId: expect.any(String),\n          method: 'GET',\n          url: '/health/debug'\n        })\n      });\n      \n      process.env.NODE_ENV = originalEnv;\n    });\n    \n    it('should return 404 in production', async () => {\n      const originalEnv = process.env.NODE_ENV;\n      process.env.NODE_ENV = 'production';\n      \n      const response = await request(app)\n        .get('/health/debug')\n        .expect(404);\n      \n      expect(response.body.error).toBe('Not found');\n      \n      process.env.NODE_ENV = originalEnv;\n    });\n    \n    it('should handle debug endpoint errors', async () => {\n      const originalEnv = process.env.NODE_ENV;\n      process.env.NODE_ENV = 'development';\n      \n      mockMonitoring.getMetricsCollector.mockImplementation(() => {\n        throw new Error('Debug error');\n      });\n      \n      const response = await request(app)\n        .get('/health/debug')\n        .expect(500);\n      \n      expect(response.body).toMatchObject({\n        error: 'Failed to generate debug info',\n        message: 'Debug error'\n      });\n      \n      process.env.NODE_ENV = originalEnv;\n    });\n  });\n});\n\ndescribe('Health Routes Integration', () => {\n  it('should handle concurrent health checks', async () => {\n    mockMonitoring.getHealthStatus.mockResolvedValue({\n      status: 'healthy',\n      checks: []\n    });\n    \n    // Make 5 concurrent requests\n    const promises = Array(5).fill(null).map(() => \n      request(app).get('/health').expect(200)\n    );\n    \n    const responses = await Promise.all(promises);\n    \n    responses.forEach(response => {\n      expect(response.body.status).toBe('healthy');\n      expect(response.headers['x-correlation-id']).toBeDefined();\n    });\n    \n    // Each request should have unique correlation ID\n    const correlationIds = responses.map(r => r.headers['x-correlation-id']);\n    const uniqueIds = new Set(correlationIds);\n    expect(uniqueIds.size).toBe(5);\n  });\n  \n  it('should measure and report health check performance', async () => {\n    mockMonitoring.getHealthStatus.mockImplementation(async () => {\n      // Simulate slow health check\n      await new Promise(resolve => setTimeout(resolve, 100));\n      return {\n        status: 'healthy',\n        checks: []\n      };\n    });\n    \n    const response = await request(app)\n      .get('/health')\n      .expect(200);\n    \n    expect(response.body.duration).toBeGreaterThan(90); // Should be ~100ms\n  });\n  \n  it('should handle health check timeout scenarios', async () => {\n    mockMonitoring.getHealthStatus.mockImplementation(async () => {\n      // Simulate very slow health check\n      await new Promise(resolve => setTimeout(resolve, 10000));\n      return {\n        status: 'healthy',\n        checks: []\n      };\n    });\n    \n    // The test should complete quickly, not wait for the full 10 seconds\n    const startTime = Date.now();\n    \n    try {\n      await request(app)\n        .get('/health')\n        .timeout(1000); // 1 second timeout\n    } catch (error) {\n      // Timeout is expected\n    }\n    \n    const duration = Date.now() - startTime;\n    expect(duration).toBeLessThan(2000); // Should timeout within 2 seconds\n  });\n});